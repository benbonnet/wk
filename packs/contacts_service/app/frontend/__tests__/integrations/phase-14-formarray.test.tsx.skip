import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { UIProvider } from "@ui/lib/provider";
import { TooltipProvider } from "@ui-components/tooltip";
import { VIEW, FORM, FORM_ARRAY, GROUP } from "@ui/adapters/layouts";
import { INPUT_TEXT } from "@ui/adapters/inputs";
import { COMPONENT, SUBMIT } from "@ui/adapters/primitives";
import type { AdapterRegistry, UIServices } from "@ui/lib/registry";
import type { ReactNode } from "react";

function createMockServices(overrides?: Partial<UIServices>): UIServices {
  return {
    fetch: vi.fn().mockResolvedValue({ data: {} }),
    navigate: vi.fn(),
    toast: vi.fn(),
    confirm: vi.fn().mockResolvedValue(true),
    ...overrides,
  };
}

const mockAdapters: AdapterRegistry = {
  VIEW,
  FORM,
  FORM_ARRAY,
  GROUP,
  COMPONENT,
  SUBMIT,
  INPUT_TEXT,
} as AdapterRegistry;

interface WrapperProps {
  children: ReactNode;
  services?: UIServices;
  translations?: Record<string, string>;
}

function TestWrapper({
  children,
  services = createMockServices(),
  translations = {},
}: WrapperProps) {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  return (
    <QueryClientProvider client={queryClient}>
      <UIProvider
        adapters={mockAdapters}
        services={services}
        translations={{ views: translations, schemas: {}, common: {} }}
        locale="en"
      >
        <TooltipProvider>{children}</TooltipProvider>
      </UIProvider>
    </QueryClientProvider>
  );
}

describe("Phase 14: FORM_ARRAY (Dynamic Fields)", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("14.1 Array Rendering", () => {
    it("FORM_ARRAY renders template for each array item", () => {
      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM
              schema={{ type: "FORM" }}
              defaultValues={{
                addresses: [
                  { street: "123 Main St" },
                  { street: "456 Oak Ave" },
                ],
              }}
            >
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "addresses",
                  label: "Addresses",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "street", label: "Street" },
                  ],
                }}
                name="addresses"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // Should have 2 street inputs (one per array item)
      const streetInputs = screen.getAllByLabelText("Street");
      expect(streetInputs).toHaveLength(2);
    });

    it("FORM_ARRAY renders empty state when array empty", () => {
      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ items: [] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "items",
                  label: "Items",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "name", label: "Name" },
                  ],
                }}
                name="items"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // No name inputs when array is empty
      expect(screen.queryByLabelText("Name")).not.toBeInTheDocument();
      // But add button should be present
      expect(screen.getByRole("button", { name: /Add Item/i })).toBeInTheDocument();
    });

    it("FORM_ARRAY renders add button with addLabel", () => {
      render(
        <TestWrapper translations={{ add_address: "Add New Address" }}>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ addresses: [] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "addresses",
                  addLabel: "add_address",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "street", label: "Street" },
                  ],
                }}
                name="addresses"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      expect(screen.getByRole("button", { name: "Add New Address" })).toBeInTheDocument();
    });

    it("FORM_ARRAY renders label from schema", () => {
      render(
        <TestWrapper translations={{ addresses_label: "Shipping Addresses" }}>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ addresses: [] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "addresses",
                  label: "addresses_label",
                  template: [],
                }}
                name="addresses"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      expect(screen.getByText("Shipping Addresses")).toBeInTheDocument();
    });
  });

  describe("14.2 Array Manipulation", () => {
    it("Click add button adds new item from template", async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ phones: [] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "phones",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "number", label: "Phone Number" },
                  ],
                }}
                name="phones"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // Initially no phone inputs
      expect(screen.queryByLabelText("Phone Number")).not.toBeInTheDocument();

      // Click add
      await user.click(screen.getByRole("button", { name: /Add Item/i }));

      // Now should have one phone input
      expect(screen.getByLabelText("Phone Number")).toBeInTheDocument();

      // Click add again
      await user.click(screen.getByRole("button", { name: /Add Item/i }));

      // Now should have two phone inputs
      expect(screen.getAllByLabelText("Phone Number")).toHaveLength(2);
    });

    it("Each item has remove button", async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ items: [{ name: "Item 1" }] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "items",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "name", label: "Name" },
                  ],
                }}
                name="items"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // Should have remove button
      expect(screen.getByRole("button", { name: /Remove/i })).toBeInTheDocument();
    });

    it("Click remove removes item from array", async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM
              schema={{ type: "FORM" }}
              defaultValues={{
                items: [{ name: "First" }, { name: "Second" }],
              }}
            >
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "items",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "name", label: "Name" },
                  ],
                }}
                name="items"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // Initially 2 items
      expect(screen.getAllByLabelText("Name")).toHaveLength(2);

      // Remove first item
      const removeButtons = screen.getAllByRole("button", { name: /Remove/i });
      await user.click(removeButtons[0]);

      // Now should have 1 item
      await waitFor(() => {
        expect(screen.getAllByLabelText("Name")).toHaveLength(1);
      });
    });

    it("Item indices update after removal", async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM
              schema={{ type: "FORM" }}
              defaultValues={{
                items: [{ name: "A" }, { name: "B" }, { name: "C" }],
              }}
            >
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "items",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "name", label: "Name" },
                  ],
                }}
                name="items"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      // Remove middle item (B)
      const removeButtons = screen.getAllByRole("button", { name: /Remove/i });
      await user.click(removeButtons[1]);

      // Should have 2 items remaining
      await waitFor(() => {
        expect(screen.getAllByLabelText("Name")).toHaveLength(2);
      });
    });
  });

  describe("14.3 Array Data", () => {
    it("Array field input is rendered and interactive", async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM schema={{ type: "FORM" }} defaultValues={{ phones: [{ number: "" }] }}>
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "phones",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "number", label: "Phone" },
                  ],
                }}
                name="phones"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      const phoneInput = screen.getByLabelText("Phone");
      expect(phoneInput).toBeInTheDocument();

      // Input should be focusable and interactive
      await user.click(phoneInput);
      expect(phoneInput).toHaveFocus();
    });

    it("Multiple array items render independent inputs", async () => {
      render(
        <TestWrapper>
          <VIEW schema={{ type: "VIEW" }}>
            <FORM
              schema={{ type: "FORM" }}
              defaultValues={{ contacts: [{ email: "a@test.com" }, { email: "b@test.com" }] }}
            >
              <FORM_ARRAY
                schema={{
                  type: "FORM_ARRAY",
                  name: "contacts",
                  template: [
                    { type: "COMPONENT", kind: "INPUT_TEXT", name: "email", label: "Email" },
                  ],
                }}
                name="contacts"
              />
            </FORM>
          </VIEW>
        </TestWrapper>
      );

      const emailInputs = screen.getAllByLabelText("Email");

      // Each array item should have its own input
      expect(emailInputs).toHaveLength(2);
      // Inputs should be distinct elements
      expect(emailInputs[0]).not.toBe(emailInputs[1]);
    });
  });
});

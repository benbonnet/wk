# Item Normalization: Flatten `data` to Top-Level Attributes

## Problem Statement

Currently, Items store domain data in a `data` JSONB column. The API returns:

```json
{ "id": 1, "data": { "first_name": "John", "last_name": "Doe" } }
```

This forces the frontend to handle nested `data` extraction everywhere. We want Items to **look like ActiveRecord models**:

```json
{ "id": 1, "first_name": "John", "last_name": "Doe" }
```

## Solution Overview

1. **Serializer**: Flatten `item.data` fields to top-level in API responses
2. **Controller**: Wrap incoming flat params back into `data` for storage
3. **Validation errors**: Return flat field names (not `data.field_name`)
4. **Frontend**: Remove `data` nesting/extraction logic

---

## Serializers as Decorators

Serializers act as a **presentation layer** for Items - similar to Draper decorators but for API output. They provide:

1. **Flattening**: `item.data` fields become top-level attributes
2. **Computed fields**: Derived values not stored in the database
3. **Field overrides**: Transform or format schema fields
4. **Relationship shortcuts**: Convenient accessors for related data

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    BaseItemSerializer                        │
│  - Flattens item.data to top-level                          │
│  - Loads relationships ONCE (cached for reuse)              │
│  - Adds *_attributes for form consumption                   │
│  - Passes relationships to custom_attributes        │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
     ContactSerializer  RibRequestSerializer  ...
     - schema ContactSchema
     - computed: full_name, primary_email
     - overrides: formatted_phone
```

### Basic Example

```ruby
module ContactsService
  class ContactSerializer < Core::Serializers::BaseItemSerializer
    schema ContactSchema

    private

      def custom_attributes(item, relationships)
        {
          # Computed from schema fields
          full_name: [item.data["first_name"], item.data["last_name"]].compact.join(" "),

          # Relationship shortcuts (no extra query - uses cached relationships)
          primary_email: relationships[:emails]&.find { |e| e["is_primary"] }&.dig("address"),
          primary_phone: relationships[:phones]&.find { |p| p["is_primary"] }&.dig("number"),

          # Aggregates
          addresses_count: relationships[:addresses]&.size || 0,

          # Boolean helpers
          has_spouse: relationships[:spouse].present?
        }.compact
      end
  end
end
```

### Relationship Loading (No N+1)

Relationships are loaded **once** in `load_relationships` and passed as context to `custom_attributes`:

```ruby
def to_h
  result = super
  flattened = result.delete(:_flattened_data) || {}

  # Load ALL relationships in one batch query
  relationships = load_relationships(@object)

  # Add as *_attributes for forms
  relationships.each do |name, data|
    flattened["#{name}_attributes"] = data
  end

  # Computed attributes receive relationships - no extra queries
  computed = custom_attributes(@object, relationships)
  flattened.merge!(computed)

  result.merge(flattened.transform_keys(&:to_sym))
end
```

The `relationships` hash structure:

```ruby
{
  emails: [
    { "id" => 1, "address" => "john@example.com", "is_primary" => true },
    { "id" => 2, "address" => "john.work@company.com", "is_primary" => false }
  ],
  phones: [
    { "id" => 3, "number" => "+33612345678", "is_primary" => true }
  ],
  addresses: [...],
  spouse: { "id" => 5, "first_name" => "Jane", ... }  # has_one (single object, not array)
}
```

### View Consumption

Views can reference **any field** the serializer provides - both schema fields and computed ones:

```ruby
# Table columns - mix schema and computed fields freely
table do |t|
  t.column :full_name, type: "DISPLAY_TEXT", label: "name"         # computed
  t.column :primary_email, type: "DISPLAY_TEXT", label: "email"    # computed
  t.column :company, type: "DISPLAY_TEXT"                          # schema field
  t.column :addresses_count, type: "DISPLAY_NUMBER", label: "addresses"  # computed
end

# Show view
show do
  render :full_name, type: "DISPLAY_TEXT", label: "name"
  render :primary_email, type: "DISPLAY_TEXT", label: "email"
  render :has_spouse, type: "DISPLAY_BOOLEAN", label: "married"
  render :company, type: "DISPLAY_TEXT"  # schema field
end
```

### Common Patterns

#### Formatted Dates

```ruby
birth_date_formatted: begin
  date = item.data["date_of_birth"]
  Date.parse(date).strftime("%B %d, %Y") if date
end
```

#### Enum Labels

```ruby
status_label: STATUS_LABELS[item.data["status"]] || item.data["status"]
```

#### Currency Formatting

```ruby
amount_display: begin
  amount = item.data["amount"]
  "$#{format('%.2f', amount)}" if amount
end
```

#### Primary Record from Collection

```ruby
primary_phone: relationships[:phones]&.find { |p| p["is_primary"] }&.dig("number")
```

#### Fallback Chain

```ruby
display_name: item.data["company"] ||
  [item.data["first_name"], item.data["last_name"]].compact.join(" ") ||
  "Unknown"
```

### Separation of Concerns

| Layer          | Responsibility                                     |
| -------------- | -------------------------------------------------- |
| **Schema**     | Storage structure, validation rules, relationships |
| **Serializer** | Presentation, computed fields, formatting          |
| **View**       | UI layout, which fields to display, labels         |

### Field Validation (Optional Enhancement)

Currently, typos in view field references fail silently (empty column). Consider adding validation:

```ruby
# In view DSL
def column(name, **opts)
  available = serializer_class.available_fields
  unless available.include?(name.to_sym)
    raise ArgumentError, "Unknown field :#{name} - available: #{available.join(', ')}"
  end
  # ...
end

# In serializer
class ContactSerializer < BaseItemSerializer
  def self.available_fields
    schema_fields + computed_fields
  end

  def self.schema_fields
    schema_class.new.to_json_schema.dig(:schema, :properties)&.keys&.map(&:to_sym) || []
  end

  def self.computed_fields
    # Introspect custom_attributes or maintain explicit list
    [:full_name, :primary_email, :primary_phone, :addresses_count, :has_spouse]
  end
end
```

---

## Phase 1: Backend - Per-Service Serializers

### 1.1 Create Base Item Serializer

**File**: `packs/core/app/lib/core/serializers/base_item_serializer.rb`

```ruby
# frozen_string_literal: true

module Core
  module Serializers
    class BaseItemSerializer
      include Alba::Resource

      # Base attributes always present
      attributes :id, :workspace_id, :schema_slug, :created_by_id, :updated_by_id

      attribute :created_at do |item|
        item.created_at&.iso8601
      end

      attribute :updated_at do |item|
        item.updated_at&.iso8601
      end

      # Subclasses define which schema to use
      class << self
        attr_accessor :schema_class

        def schema(klass)
          @schema_class = klass
        end
      end

      # Dynamically flatten data fields to top-level
      def self.inherited(subclass)
        super
        subclass.instance_eval do
          attribute :_flattened_data do |item|
            item.data || {}
          end
        end
      end

      # Override Alba's to_h to merge flattened data and computed attrs
      def to_h
        result = super
        flattened = result.delete(:_flattened_data) || {}

        # Load relationships ONCE
        relationships = load_relationships(@object)

        # Add as *_attributes for forms
        relationships.each do |rel_name, rel_data|
          flattened["#{rel_name}_attributes"] = rel_data
        end

        # Add computed attributes (subclass override)
        computed = custom_attributes(@object, relationships)
        flattened.merge!(computed.stringify_keys)

        result.merge(flattened.transform_keys(&:to_sym))
      end

      private

        def load_relationships(item)
          return {} unless item.schema_slug

          schema_class = Core::Schema::Registry.find(item.schema_slug)
          return {} unless schema_class&.respond_to?(:relationships)

          relationships = schema_class.relationships || []
          return {} if relationships.empty?

          result = {}

          relationships.each do |rel|
            rel_name = rel[:name].to_sym
            cardinality = rel[:cardinality]

            rel_records = ItemRelationship
              .where(source_item_id: item.id, relationship_type: rel_name.to_s)
              .includes(:target_item)

            if cardinality == :one
              target = rel_records.first&.target_item
              result[rel_name] = target ? { "id" => target.id }.merge(target.data) : nil
            else
              result[rel_name] = rel_records.filter_map do |r|
                next unless r.target_item
                { "id" => r.target_item.id }.merge(r.target_item.data)
              end
            end
          end

          result
        end

        # Override in subclasses to add computed attributes
        def custom_attributes(_item, _relationships)
          {}
        end
    end
  end
end
```

### 1.2 Create ContactsService Serializer

**File**: `packs/contacts_service/app/lib/contacts_service/contact_serializer.rb`

```ruby
# frozen_string_literal: true

module ContactsService
  class ContactSerializer < Core::Serializers::BaseItemSerializer
    schema ContactSchema

    private

      def custom_attributes(item, relationships)
        {
          full_name: [item.data["first_name"], item.data["last_name"]].compact.join(" "),
          primary_email: relationships[:emails]&.find { |e| e["is_primary"] }&.dig("address"),
          primary_phone: relationships[:phones]&.find { |p| p["is_primary"] }&.dig("number")
        }.compact
      end
  end
end
```

### 1.3 Create RibCheckService Serializer

**File**: `packs/rib_check_service/app/lib/rib_check_service/rib_request_serializer.rb`

```ruby
# frozen_string_literal: true

module RibCheckService
  class RibRequestSerializer < Core::Serializers::BaseItemSerializer
    schema RibRequestSchema

    private

      def custom_attributes(_item, relationships)
        {
          recipients_count: relationships[:recipients]&.size || 0,
          documents_count: relationships[:documents]&.size || 0
        }
      end
  end
end
```

### 1.4 Update Tools to Use Service-Specific Serializers

**Files to update**:

| File                                                                | Change                                             |
| ------------------------------------------------------------------- | -------------------------------------------------- |
| `packs/contacts_service/app/lib/contacts_service/tools/show.rb`     | `ContactSerializer` instead of `ItemSerializer`    |
| `packs/contacts_service/app/lib/contacts_service/tools/create.rb`   | `ContactSerializer` instead of `ItemSerializer`    |
| `packs/contacts_service/app/lib/contacts_service/tools/update.rb`   | `ContactSerializer` instead of `ItemSerializer`    |
| `packs/contacts_service/app/lib/contacts_service/tools/index.rb`    | `ContactSerializer` instead of `ItemSerializer`    |
| `packs/rib_check_service/app/lib/rib_check_service/tools/show.rb`   | `RibRequestSerializer` instead of `ItemSerializer` |
| `packs/rib_check_service/app/lib/rib_check_service/tools/create.rb` | `RibRequestSerializer` instead of `ItemSerializer` |
| `packs/rib_check_service/app/lib/rib_check_service/tools/update.rb` | `RibRequestSerializer` instead of `ItemSerializer` |
| `packs/rib_check_service/app/lib/rib_check_service/tools/index.rb`  | `RibRequestSerializer` instead of `ItemSerializer` |

**Example change** (`contacts_service/tools/show.rb`):

```ruby
# Before
{ data: Core::Serializers::ItemSerializer.new(item).to_h }

# After
{ data: ContactSerializer.new(item).to_h }
```

---

## Phase 2: Backend - Controller Param Wrapping & Validation Errors

### 2.1 Update RailsParameters to Build Flat Permit Structure

**File**: `packs/core/app/lib/core/tools/rails_parameters.rb`

```ruby
# Current: [:id, data: [:first_name, :last_name, ...]]
# New:     [:id, :first_name, :last_name, ...]

def self.permit_structure(tool_class)
  schema = tool_class.new.params_schema
  return [] unless schema && schema["properties"]

  schema_class = tool_class.respond_to?(:schema_class) ? tool_class.schema_class : nil

  # For tools with schema, flatten the data object
  if schema_class
    build_flat_permit_structure(schema["properties"], schema_class)
  else
    build_permit_structure(schema["properties"], schema_class)
  end
end

private_class_method def self.build_flat_permit_structure(properties, schema_class)
  result = []

  properties.each do |key, prop|
    key_sym = key.to_sym

    if key == "data" && prop["type"] == "object" && prop["properties"]
      # Flatten data fields to top-level
      prop["properties"].each_key do |data_key|
        result << data_key.to_sym
      end
      # Add relationship attributes
      if schema_class&.respond_to?(:relationships)
        schema_class.relationships.each do |rel|
          attr_key = :"#{rel[:name]}_attributes"
          target_schema = Schema::Registry.find(rel[:target_schema])
          json_schema = target_schema&.new&.to_json_schema
          target_fields = json_schema&.dig(:schema, :properties)&.keys&.map(&:to_sym) || []
          result << { attr_key => [:id, :_destroy] + target_fields }
        end
      end
    elsif prop["type"] != "object"
      result << key_sym
    end
  end

  result
end
```

### 2.2 Update ResourcesController to Wrap Flat Params

**File**: `packs/core/app/controllers/core/v1/resources_controller.rb`

```ruby
def tool_params
  permitted = Tools::RailsParameters.permit_structure(@tool_class)
  flat_params = params.permit(:namespace, :feature, :action_name, *permitted).to_h
    .except("namespace", "feature", "action_name")
    .deep_symbolize_keys

  # If tool expects :data param, wrap schema fields into it
  if @tool_class.respond_to?(:schema_class) && @tool_class.schema_class
    wrap_into_data(flat_params, @tool_class.schema_class)
  else
    flat_params
  end
end

private

  def wrap_into_data(flat_params, schema_class)
    schema_fields = schema_class.new.to_json_schema.dig(:schema, :properties)&.keys || []
    relationship_keys = schema_class.relationships.map { |r| "#{r[:name]}_attributes" }
    all_data_keys = schema_fields + relationship_keys

    data = {}
    other = {}

    flat_params.each do |key, value|
      if all_data_keys.include?(key.to_s)
        data[key] = value
      else
        other[key] = value
      end
    end

    other.merge(data: data)
  end
```

### 2.3 Update Schema Validation to Return Flat Error Field Names

**File**: `packs/core/app/models/concerns/core/has_schema_validation.rb`

```ruby
# frozen_string_literal: true

require "json-schema"

module Core
  module HasSchemaValidation
    extend ActiveSupport::Concern

    included do
      validate :validate_schema_slug_exists
      validate :validate_data_against_schema, if: -> { data.present? && schema_slug.present? }
    end

    private

      def validate_schema_slug_exists
        return if schema_slug.blank?
        return if Core::Schema::Registry.find(schema_slug)

        errors.add(:schema_slug, "is not a registered schema")
      end

      def validate_data_against_schema
        schema_class = Core::Schema::Registry.find(schema_slug)
        return unless schema_class

        json_schema = schema_class.new.to_json_schema[:schema]
        return unless json_schema

        # Strip nested attributes before validation
        clean_data = data.to_h.reject { |k, _| k.to_s.end_with?("_attributes") }

        validation_errors = JSON::Validator.fully_validate(
          json_schema.deep_stringify_keys,
          clean_data.deep_stringify_keys,
          strict: false,
          validate_schema: false
        )

        validation_errors.each do |error|
          # Parse JSON Schema error path and map to flat field name
          # Example: "The property '#/first_name' is required" → :first_name, "is required"
          if (match = error.match(/'#\/([^']+)'/))
            field = match[1].to_sym
            message = error.gsub(/'#\/[^']+'\s*/, "").strip
            errors.add(field, message)
          else
            errors.add(:base, error)
          end
        end
      rescue JSON::Schema::ValidationError => e
        errors.add(:base, "Schema validation error: #{e.message}")
      end
  end
end
```

---

## Phase 3: Frontend Changes

### 3.1 Update Form Adapter

**File**: `packs/ui/app/frontend/adapters/custom/form/form.tsx`

**Changes**:

```typescript
// Line 28-31: Remove data extraction - drawerData is now flat
// BEFORE:
const recordData = drawerData?.data ?? drawerData;
const initialData = use_record && recordData ? recordData : defaultValues;

// AFTER:
const initialData = use_record && drawerData ? drawerData : defaultValues;


// Line 69: Remove data wrapper - send flat values
// BEFORE:
body: { data: values },

// AFTER:
body: values,


// Line 104-108: Remove data extraction in resetForm
// BEFORE:
const formValues = drawerData?.data ?? drawerData;
resetForm({ values: formValues });

// AFTER:
resetForm({ values: drawerData });
```

### 3.2 Update Show Adapter

**File**: `packs/ui/app/frontend/adapters/layouts/show.tsx`

**Changes**:

```typescript
// Line 37-42: Remove data extraction - drawerData is now flat
// BEFORE:
const contextData = drawerData?.data ?? drawerData;
const showData = contextData ?? data ?? record ?? {};

// AFTER:
const showData = drawerData ?? data ?? record ?? {};
```

### 3.3 Update Table Adapter

**File**: `packs/ui/app/frontend/adapters/custom/table/table.tsx`

**Changes**:

```typescript
// Line 124-125: Simplify accessorFn - data is now flat
// BEFORE:
accessorFn: (row: DataTableRow) =>
  (row.data as Record<string, unknown>)?.[col.name] ?? row[col.name],

// AFTER:
accessorFn: (row: DataTableRow) => row[col.name],
```

### 3.4 Update Relationship Picker Create Drawer

**File**: `packs/ui/app/frontend/adapters/custom/relationship-picker/create-drawer.tsx`

**Changes**:

```typescript
// Line 55-58: Remove data wrapper in POST
// BEFORE:
data: { data: formValues },

// AFTER:
data: formValues,


// Line 66-68: Simplify response handling - already flat
// BEFORE:
const item = response.data;
onSuccess({ id: item.id, ...item.data });

// AFTER:
onSuccess(response.data);
```

---

## Phase 4: Test Updates

### 4.1 Backend Spec Updates

**Files to update**:

| File                                                                          | Change                                           |
| ----------------------------------------------------------------------------- | ------------------------------------------------ |
| `packs/contacts_service/spec/requests/contacts_spec.rb`                       | Update response expectations - no `data` wrapper |
| `packs/rib_check_service/spec/requests/rib_requests_spec.rb`                  | Update response expectations                     |
| `packs/core/spec/lib/core/serializers/base_item_serializer_spec.rb`           | CREATE - specs for base serializer               |
| `packs/contacts_service/spec/lib/contacts_service/contact_serializer_spec.rb` | CREATE - specs for computed fields               |
| `packs/core/spec/models/concerns/core/has_schema_validation_spec.rb`          | Update error format expectations                 |

**Example response expectation change**:

```ruby
# Before
expect(body["data"]["data"]["first_name"]).to eq("John")

# After
expect(body["data"]["first_name"]).to eq("John")
```

**Example validation error expectation change**:

```ruby
# Before
expect(item.errors[:data]).to include(/first_name/)

# After
expect(item.errors[:first_name]).to be_present
```

### 4.2 Serializer Specs

**File**: `packs/core/spec/lib/core/serializers/base_item_serializer_spec.rb`

```ruby
# frozen_string_literal: true

require "rails_helper"

RSpec.describe Core::Serializers::BaseItemSerializer do
  let(:workspace) { create(:workspace) }
  let(:user) { create(:user) }

  describe "#to_h" do
    it "flattens data to top-level attributes" do
      item = create(:item,
        workspace:,
        schema_slug: "contact",
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe" }
      )

      result = described_class.new(item).to_h

      expect(result[:first_name]).to eq("John")
      expect(result[:last_name]).to eq("Doe")
      expect(result).not_to have_key(:data)
    end

    it "includes base attributes" do
      item = create(:item, workspace:, schema_slug: "contact", created_by: user, data: {})

      result = described_class.new(item).to_h

      expect(result[:id]).to eq(item.id)
      expect(result[:workspace_id]).to eq(workspace.id)
      expect(result[:schema_slug]).to eq("contact")
      expect(result[:created_at]).to be_present
    end
  end
end
```

**File**: `packs/contacts_service/spec/lib/contacts_service/contact_serializer_spec.rb`

```ruby
# frozen_string_literal: true

require "rails_helper"

RSpec.describe ContactsService::ContactSerializer do
  let(:workspace) { create(:workspace) }
  let(:user) { create(:user) }

  describe "computed attributes" do
    it "computes full_name from first_name and last_name" do
      item = create(:item,
        workspace:,
        schema_slug: "contact",
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe" }
      )

      result = described_class.new(item).to_h

      expect(result[:full_name]).to eq("John Doe")
    end

    it "computes primary_email from emails relationship" do
      contact = create(:item,
        workspace:,
        schema_slug: "contact",
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe" }
      )

      email1 = create(:item,
        workspace:,
        schema_slug: "email",
        created_by: user,
        data: { "address" => "john@example.com", "is_primary" => false }
      )

      email2 = create(:item,
        workspace:,
        schema_slug: "email",
        created_by: user,
        data: { "address" => "john.primary@example.com", "is_primary" => true }
      )

      ItemRelationship.create!(source_item: contact, target_item: email1, relationship_type: "emails")
      ItemRelationship.create!(source_item: contact, target_item: email2, relationship_type: "emails")

      result = described_class.new(contact).to_h

      expect(result[:primary_email]).to eq("john.primary@example.com")
    end
  end

  describe "view field compatibility" do
    it "provides both schema fields and computed fields for view consumption" do
      item = create(:item,
        workspace:,
        schema_slug: "contact",
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe", "company" => "Acme" }
      )

      result = described_class.new(item).to_h

      # Schema fields
      expect(result[:first_name]).to eq("John")
      expect(result[:last_name]).to eq("Doe")
      expect(result[:company]).to eq("Acme")

      # Computed fields
      expect(result[:full_name]).to eq("John Doe")
    end
  end
end
```

### 4.3 Frontend Test Updates

**Files to update**:

| File                                                                                              | Changes Needed                               |
| ------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| `packs/contacts_service/app/frontend/__tests__/integrations/phase-11-api.test.tsx`                | Remove `data:` wrapper in fetch expectations |
| `packs/contacts_service/app/frontend/__tests__/integrations/phase-12-fullpage.test.tsx`           | Verify mock data format (already flat)       |
| `packs/contacts_service/app/frontend/__tests__/integrations/phase-13-relationshippicker.test.tsx` | Update mock response handling                |
| `packs/rib_check_service/app/frontend/__tests__/integrations/rib-requests.test.tsx`               | Update expectations                          |

**Example change** (`phase-11-api.test.tsx`):

```typescript
// Before
expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
  method: "POST",
  data: { data: { name: "Test Contact" } },
});

// After
expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
  method: "POST",
  data: { name: "Test Contact" },
});
```

---

## Phase 5: Regenerate Mocks

After all changes, regenerate frontend mocks:

```bash
bundle exec rake core:export_mocks
```

---

## Execution Order

1. **Phase 1.1-1.3**: Create BaseItemSerializer and service serializers
2. **Phase 1.4**: Update tools to use new serializers
3. **Phase 2.1-2.2**: Update RailsParameters and ResourcesController
4. **Phase 2.3**: Update has_schema_validation for flat error field names
5. **Run backend specs** - fix failures
6. **Phase 3**: Update frontend adapters
7. **Phase 4**: Update tests
8. **Phase 5**: Regenerate mocks
9. **Run full test suite**

---

## Files Changed Summary

### Backend (Ruby) - 16 files

| File                                                                          | Action |
| ----------------------------------------------------------------------------- | ------ |
| `packs/core/app/lib/core/serializers/base_item_serializer.rb`                 | CREATE |
| `packs/contacts_service/app/lib/contacts_service/contact_serializer.rb`       | CREATE |
| `packs/rib_check_service/app/lib/rib_check_service/rib_request_serializer.rb` | CREATE |
| `packs/contacts_service/app/lib/contacts_service/tools/show.rb`               | EDIT   |
| `packs/contacts_service/app/lib/contacts_service/tools/create.rb`             | EDIT   |
| `packs/contacts_service/app/lib/contacts_service/tools/update.rb`             | EDIT   |
| `packs/contacts_service/app/lib/contacts_service/tools/index.rb`              | EDIT   |
| `packs/rib_check_service/app/lib/rib_check_service/tools/show.rb`             | EDIT   |
| `packs/rib_check_service/app/lib/rib_check_service/tools/create.rb`           | EDIT   |
| `packs/rib_check_service/app/lib/rib_check_service/tools/update.rb`           | EDIT   |
| `packs/rib_check_service/app/lib/rib_check_service/tools/index.rb`            | EDIT   |
| `packs/core/app/lib/core/tools/rails_parameters.rb`                           | EDIT   |
| `packs/core/app/controllers/core/v1/resources_controller.rb`                  | EDIT   |
| `packs/core/app/models/concerns/core/has_schema_validation.rb`                | EDIT   |
| `packs/contacts_service/spec/requests/contacts_spec.rb`                       | EDIT   |
| `packs/rib_check_service/spec/requests/rib_requests_spec.rb`                  | EDIT   |

### Backend Specs (Ruby) - 3 files

| File                                                                          | Action |
| ----------------------------------------------------------------------------- | ------ |
| `packs/core/spec/lib/core/serializers/base_item_serializer_spec.rb`           | CREATE |
| `packs/contacts_service/spec/lib/contacts_service/contact_serializer_spec.rb` | CREATE |
| `packs/core/spec/models/concerns/core/has_schema_validation_spec.rb`          | EDIT   |

### Frontend (TypeScript) - 8 files

| File                                                                                              | Action                |
| ------------------------------------------------------------------------------------------------- | --------------------- |
| `packs/ui/app/frontend/adapters/custom/form/form.tsx`                                             | EDIT (3 changes)      |
| `packs/ui/app/frontend/adapters/layouts/show.tsx`                                                 | EDIT (1 change)       |
| `packs/ui/app/frontend/adapters/custom/table/table.tsx`                                           | EDIT (1 change)       |
| `packs/ui/app/frontend/adapters/custom/relationship-picker/create-drawer.tsx`                     | EDIT (2 changes)      |
| `packs/contacts_service/app/frontend/__tests__/integrations/phase-11-api.test.tsx`                | EDIT                  |
| `packs/contacts_service/app/frontend/__tests__/integrations/phase-13-relationshippicker.test.tsx` | EDIT                  |
| `packs/rib_check_service/app/frontend/__tests__/integrations/rib-requests.test.tsx`               | EDIT                  |
| `packs/contacts_service/app/frontend/__tests__/mocks/data.json`                                   | VERIFY (already flat) |

---

## Risk Assessment

| Risk                                | Mitigation                                            |
| ----------------------------------- | ----------------------------------------------------- |
| Breaking existing API consumers     | This is internal API - no external consumers          |
| Missing edge cases in serialization | Existing ItemSerializer tests provide coverage        |
| Relationship data format change     | Relationships already flatten target.data - no change |
| Form submission failures            | Comprehensive test coverage in phase-11, phase-13     |
| Validation error format change      | Update frontend error handling if needed              |

---

## Rollback Plan

If issues arise:

1. Revert BaseItemSerializer changes
2. Keep ItemSerializer as-is
3. Frontend changes are isolated to 4 adapter files - easy revert

---

## Success Criteria

1. All backend specs pass
2. All frontend tests pass
3. API responses have flat structure: `{ id, first_name, last_name, full_name, ... }`
4. Forms submit flat data: `{ first_name, last_name, ... }`
5. Validation errors reference flat field names: `{ first_name: ["is required"] }`
6. No `drawerData?.data` extraction in frontend code
7. Views can use both schema fields and computed serializer fields

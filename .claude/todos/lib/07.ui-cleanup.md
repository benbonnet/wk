# UI Cleanup: Schema/Component Boundary

## Problem

Current design mixes schema and component concerns:

- Components take `{ schema }` prop and read everything from it
- Forces awkward `<INPUT_TEXT schema={{ type: "INPUT_TEXT", name: "foo" }} />`
- Components can't be used directly without schema ceremony
- Tests/stories have redundant `type` declarations
- Adapters split across `inputs/`, `displays/`, `primitives/`, `layouts/` for no runtime reason

## Solution

Clear boundary: **schema logic stops at the renderer**.

```
SCHEMA WORLD                          COMPONENT WORLD
─────────────────────────────────────────────────────────
Backend JSON                          Normal React components
     ↓                                     ↑
DynamicRenderer                       <TextInput name="x" />
  - looks up registry[schema.type]    <Select options={[...]} />
  - spreads schema as props           <Page title="..." />
     ↓                                     ↑
<Component {...schema} />  ──────────────→
```

## Changes

### 1. Flatten adapters folder

**Before:**

```
adapters/
  inputs/
    text-input.tsx
    select.tsx
    index.ts
  displays/
    text-display.tsx
    index.ts
  primitives/
    button.tsx
    index.ts
  layouts/
    page.tsx
    form.tsx
    index.ts
```

**After:**

```
adapters/
  text-input.tsx
  select.tsx
  checkbox.tsx
  text-display.tsx
  date-display.tsx
  button.tsx
  link.tsx
  page.tsx
  form.tsx
  table.tsx
  ...
  registry.ts       # maps schema types to components
  index.ts          # exports registry + DynamicRenderer
```

### 2. Rename components (SCREAMING_CASE → PascalCase)

| Old                   | New                  |
| --------------------- | -------------------- |
| `INPUT_TEXT`          | `TextInput`          |
| `INPUT_TEXTAREA`      | `Textarea`           |
| `INPUT_SELECT`        | `Select`             |
| `INPUT_CHECKBOX`      | `Checkbox`           |
| `INPUT_CHECKBOXES`    | `Checkboxes`         |
| `INPUT_RADIOS`        | `Radios`             |
| `INPUT_DATE`          | `DateInput`          |
| `INPUT_DATETIME`      | `DatetimeInput`      |
| `INPUT_TAGS`          | `TagsInput`          |
| `INPUT_AI_RICH_TEXT`  | `RichTextInput`      |
| `DISPLAY_TEXT`        | `TextDisplay`        |
| `DISPLAY_LONGTEXT`    | `LongtextDisplay`    |
| `DISPLAY_NUMBER`      | `NumberDisplay`      |
| `DISPLAY_DATE`        | `DateDisplay`        |
| `DISPLAY_DATETIME`    | `DatetimeDisplay`    |
| `DISPLAY_BADGE`       | `BadgeDisplay`       |
| `DISPLAY_TAGS`        | `TagsDisplay`        |
| `DISPLAY_BOOLEAN`     | `BooleanDisplay`     |
| `DISPLAY_SELECT`      | `SelectDisplay`      |
| `VIEW`                | `View`               |
| `PAGE`                | `Page`               |
| `DRAWER`              | `Drawer`             |
| `FORM`                | `Form`               |
| `TABLE`               | `Table`              |
| `SHOW`                | `Show`               |
| `ACTIONS`             | `Actions`            |
| `GROUP`               | `Group`              |
| `CARD_GROUP`          | `CardGroup`          |
| `MULTISTEP`           | `Multistep`          |
| `STEP`                | `Step`               |
| `FORM_ARRAY`          | `FormArray`          |
| `DISPLAY_ARRAY`       | `DisplayArray`       |
| `ALERT`               | `Alert`              |
| `LINK`                | `Link`               |
| `BUTTON`              | `Button`             |
| `DROPDOWN`            | `Dropdown`           |
| `OPTION`              | `Option`             |
| `SEARCH`              | `Search`             |
| `SUBMIT`              | `Submit`             |
| `RELATIONSHIP_PICKER` | `RelationshipPicker` |

### 3. Change component signatures (schema → props)

**Before:**

```tsx
export function INPUT_TEXT({ schema }: BaseComponentProps) {
  const name = schema.name!;
  const label = schema.label;
  const placeholder = schema.placeholder;
  // ...
}
```

**After:**

```tsx
export function TextInput({
  name,
  label,
  placeholder,
  disabled,
  helperText,
}: TextInputProps) {
  // props used directly
}
```

### 4. Create registry mapping

```tsx
// adapters/registry.ts
import { TextInput } from "./text-input";
import { Select } from "./select";
import { TextDisplay } from "./text-display";
import { Page } from "./page";
import { Form } from "./form";
// ... all components

import type { AdapterRegistry } from "@ui/lib/types";

export const registry: AdapterRegistry = {
  // Inputs
  INPUT_TEXT: TextInput,
  INPUT_TEXTAREA: Textarea,
  INPUT_SELECT: Select,
  INPUT_CHECKBOX: Checkbox,
  INPUT_CHECKBOXES: Checkboxes,
  INPUT_RADIOS: Radios,
  INPUT_DATE: DateInput,
  INPUT_DATETIME: DatetimeInput,
  INPUT_TAGS: TagsInput,
  INPUT_AI_RICH_TEXT: RichTextInput,

  // Displays
  DISPLAY_TEXT: TextDisplay,
  DISPLAY_LONGTEXT: LongtextDisplay,
  DISPLAY_NUMBER: NumberDisplay,
  DISPLAY_DATE: DateDisplay,
  DISPLAY_DATETIME: DatetimeDisplay,
  DISPLAY_BADGE: BadgeDisplay,
  DISPLAY_TAGS: TagsDisplay,
  DISPLAY_BOOLEAN: BooleanDisplay,
  DISPLAY_SELECT: SelectDisplay,

  // Layouts
  VIEW: View,
  PAGE: Page,
  DRAWER: Drawer,
  FORM: Form,
  TABLE: Table,
  SHOW: Show,
  ACTIONS: Actions,
  GROUP: Group,
  CARD_GROUP: CardGroup,
  MULTISTEP: Multistep,
  STEP: Step,
  FORM_ARRAY: FormArray,
  DISPLAY_ARRAY: DisplayArray,
  ALERT: Alert,

  // Primitives
  LINK: Link,
  BUTTON: Button,
  DROPDOWN: Dropdown,
  OPTION: Option,
  SEARCH: Search,
  SUBMIT: Submit,
  RELATIONSHIP_PICKER: RelationshipPicker,
};
```

### 5. Update DynamicRenderer

```tsx
// lib/renderer.tsx
import { registry } from "@ui/adapters/registry";

export function DynamicRenderer({ schema, data = {} }: DynamicRendererProps) {
  const { visible, enabled } = resolveRules(schema.rules, data);
  if (!visible) return null;

  const Component = registry[schema.type];
  if (!Component) {
    console.warn(`Unknown component type: ${schema.type}`);
    return null;
  }

  const props = enabled ? schema : { ...schema, disabled: true };

  // Render children for containers
  if (schema.elements) {
    return (
      <Component {...props} data={data}>
        {schema.elements.map((child, i) => (
          <DynamicRenderer key={i} schema={child} data={data} />
        ))}
      </Component>
    );
  }

  if (schema.template) {
    return (
      <Component {...props} data={data}>
        {schema.template.map((child, i) => (
          <DynamicRenderer key={i} schema={child} data={data} />
        ))}
      </Component>
    );
  }

  return <Component {...props} data={data} />;
}
```

### 6. Update UIProvider (remove adapters prop)

```tsx
// lib/provider.tsx
interface UIProviderProps {
  children: ReactNode;
  services: UIServices;
  translations?: TranslationsMap;
  locale?: string;
  // adapters prop removed - use built-in registry
}
```

### 7. Define proper prop types for each component

```tsx
// types/props.ts

interface BaseProps {
  className?: string;
  disabled?: boolean;
  children?: ReactNode;
}

interface InputProps extends BaseProps {
  name: string;
  label?: string;
  placeholder?: string;
  helperText?: string;
}

interface TextInputProps extends InputProps {}

interface SelectProps extends InputProps {
  options: Option[];
}

interface DisplayProps extends BaseProps {
  name: string;
  label?: string;
  value?: unknown;
}

interface TextDisplayProps extends DisplayProps {
  value?: string;
}

interface SelectDisplayProps extends DisplayProps {
  value?: string;
  options: Option[];
}

interface PageProps extends BaseProps {
  title?: string;
  description?: string;
  actions?: ReactNode;
}

// ... etc for each component
```

### 8. Update tests

**Before:**

```tsx
import { INPUT_TEXT } from "@ui/adapters/inputs";

<INPUT_TEXT schema={{ type: "INPUT_TEXT", name: "email", label: "Email" }} />;
```

**After:**

```tsx
import { TextInput } from "@ui/adapters/text-input";
// OR use DynamicRenderer for integration tests

// Unit test - direct
<TextInput name="email" label="Email" />

// Integration test - via renderer
<DynamicRenderer schema={{ type: "INPUT_TEXT", name: "email", label: "Email" }} />
```

### 9. Update stories

**Before:**

```tsx
import { INPUT_TEXT } from "@ui/adapters/inputs";

export const Default: Story = {
  render: () => (
    <INPUT_TEXT
      schema={{ type: "INPUT_TEXT", name: "email", label: "Email" }}
    />
  ),
};
```

**After:**

```tsx
import { TextInput } from "@ui/adapters/text-input";

export const Default: Story = {
  render: () => <TextInput name="email" label="Email" />,
};
```

### 10. Delete old structure

Remove:

- `adapters/inputs/index.ts`
- `adapters/displays/index.ts`
- `adapters/primitives/index.ts`
- `adapters/layouts/index.ts`
- `adapters/primitives/component.tsx` (if exists)

Move all `.tsx` files up to `adapters/`.

## Execution Strategy

### Phase 1: Refactor components in place

For each component file in `adapters/inputs/`, `adapters/displays/`, `adapters/primitives/`, `adapters/layouts/`:

1. Rewrite the file in place (same path)
2. Rename function from `SCREAMING_CASE` to `PascalCase`
3. Change signature from `{ schema }: BaseComponentProps` to individual props
4. Update internal imports (e.g., `../layouts/form` → `./form` after flatten)

### Phase 2: Create registry

1. Create `adapters/registry.ts` that:
   - Imports all components from their current locations (subfolders still)
   - Maps schema types to components: `{ INPUT_TEXT: TextInput, ... }`
   - Exports the registry

### Phase 3: Update renderer and provider

1. Update `DynamicRenderer` to use built-in registry, spread props via `<Component {...schema} />`
2. Update `UIProvider` to remove `adapters` prop (registry is internal)

### Phase 4: Flatten folder structure

1. Move all `.tsx` component files from subfolders up to `adapters/`
2. Move all `.stories.tsx` files alongside their components
3. Update imports in `registry.ts` to flat paths
4. Delete old `index.ts` files in subfolders
5. Delete empty subfolders (`inputs/`, `displays/`, `primitives/`, `layouts/`)

### Phase 5: Update consumers

1. Update all tests to use `DynamicRenderer` with schemas OR direct component imports
2. Update all stories to use direct component imports with props

### Phase 6: Verify

1. Run `rake core:export_mocks`
2. Run `CI=t yarn test`

## Result

- Components are normal React components
- Schema logic isolated to `DynamicRenderer`
- Components usable directly or via schema
- Tests and stories are clean
- Flat folder structure

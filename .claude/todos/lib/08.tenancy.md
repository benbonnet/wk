# 08 - Workspace Tenancy

## Problem

Tenancy is currently weak and error-prone:
- Tools must manually add `.where(workspace_id:)` to every query
- Easy to forget, leading to data leaks across workspaces
- `Invite` model has no `workspace_id` column at all
- No validation ensuring workspace_id is always set

## Solution

Enforce tenancy at the base class level via:
1. A `WorkspaceScoped` concern for models
2. A `scoped(Model)` helper in `Core::Tools::Base`
3. Migration to add `workspace_id` to `invites`

---

## 1. WorkspaceScoped Concern

```ruby
# app/models/concerns/workspace_scoped.rb
module WorkspaceScoped
  extend ActiveSupport::Concern

  included do
    belongs_to :workspace
    validates :workspace_id, presence: true

    scope :for_workspace, ->(id) { where(workspace_id: id) }
  end
end
```

---

## 2. Models to Update

### Already have workspace_id (just add concern):

```ruby
# app/models/item.rb
class Item < ApplicationRecord
  include WorkspaceScoped
end

# app/models/activity.rb
class Activity < ApplicationRecord
  include WorkspaceScoped
end

# app/models/document.rb
class Document < ApplicationRecord
  include WorkspaceScoped
end

# app/models/feature_tool_usage.rb
class FeatureToolUsage < ApplicationRecord
  include WorkspaceScoped
end

# app/models/feature_workspace_user.rb
class FeatureWorkspaceUser < ApplicationRecord
  include WorkspaceScoped
end
```

### Needs migration + concern:

```ruby
# app/models/invite.rb
class Invite < ApplicationRecord
  include WorkspaceScoped
end
```

### Models that DON'T need WorkspaceScoped:

| Model | Reason |
|-------|--------|
| `User` | Global, not workspace-scoped |
| `Workspace` | Is the tenant itself |
| `WorkspaceUser` | Join table between User and Workspace |
| `Feature`, `FeatureTool`, `FeatureView` | Global feature definitions |
| `Schema` | Global schema definitions |
| `InviteItem` | Scoped via `belongs_to :invite` (invite is scoped) |
| `ItemRelationship` | Scoped via `belongs_to :item` (items are scoped) |
| `ItemRecipient` | Scoped via `belongs_to :item` |
| `WorkflowExecution`, `WorkflowEntry` | TBD - may need workspace_id later |

---

## 3. Migration for Invites

```ruby
# db/migrate/XXXXXX_add_workspace_id_to_invites.rb
class AddWorkspaceIdToInvites < ActiveRecord::Migration[8.0]
  def change
    add_reference :invites, :workspace, null: false, foreign_key: true, index: true
  end
end
```

**Note**: If existing invites exist, need to backfill:
- Set `null: true` initially, backfill from `invite_items -> item -> workspace_id`, then set `null: false`

---

## 4. Core::Tools::Base Updates

```ruby
# packs/core/app/lib/core/tools/base.rb
module Core
  module Tools
    class Base < RubyLLM::Tool
      include Routing

      class << self
        def execute(**params)
          instance = new
          instance.instance_variable_set(:@workspace_id, params[:workspace_id])
          instance.instance_variable_set(:@user_id, params[:user_id])
          instance.execute(**params)
        end
      end

      attr_reader :workspace_id, :user_id

      # Scoped query helper - use for ALL model queries
      def scoped(model)
        unless model.included_modules.include?(WorkspaceScoped)
          raise ArgumentError, "#{model} does not include WorkspaceScoped"
        end
        model.for_workspace(workspace_id)
      end

      # Convenience for items (most common)
      def items
        scoped(Item).where(schema_slug: self.class.schema_slug)
      end

      def find_item!(id)
        items.find(id)
      rescue ActiveRecord::RecordNotFound
        raise NotFoundError, "#{self.class.schema_slug} not found: #{id}"
      end
    end
  end
end
```

---

## 5. Tool Updates

### Before (manual scoping, error-prone):

```ruby
def execute(user_id:, workspace_id:, id:, **_)
  invite = Invite.find(id)  # BUG: no workspace check!
end
```

### After (automatic scoping):

```ruby
def execute(user_id:, workspace_id:, id:, **_)
  invite = scoped(Invite).find(id)  # Safe: scoped by workspace
end
```

### Tools requiring updates:

| Tool | Issue | Fix |
|------|-------|-----|
| `contacts/add_relationship.rb` | `Item.find(target_id)` unscoped | Use `scoped(Item).find(target_id)` |
| `invites/create.rb` | Missing `workspace_id` on create | Add `workspace_id:` to `Invite.create!` |
| `invites/cancel.rb` | `Invite.find` unscoped | Use `scoped(Invite).find(id)` |
| `items/update.rb` | `Item.find(id)` unscoped | Use `scoped(Item).find(id)` |

---

## 6. InvitesService::Tools::Create Update

```ruby
def execute(user_id:, workspace_id:, inviter_id:, invitee_id:, ...)
  invite = Invite.create!(
    workspace_id:,  # ADD THIS
    inviter_id:,
    invitee_id:,
    # ...
  )
end
```

---

## 7. Implementation Checklist

- [ ] Create `WorkspaceScoped` concern
- [ ] Add concern to models with existing `workspace_id` column
- [ ] Create migration for `invites.workspace_id`
- [ ] Run migration
- [ ] Add concern to `Invite` model
- [ ] Update `Core::Tools::Base` with `scoped()` helper and instance vars
- [ ] Update `find_item!` to use scoped `items`
- [ ] Update all tools to use `scoped(Model)` instead of `Model.find`
- [ ] Update `InvitesService::Tools::Create` to pass `workspace_id`
- [ ] Run specs, fix failures
- [ ] Add tenancy enforcement spec

---

## 8. Tenancy Enforcement Spec

```ruby
# spec/lib/core/tools/tenancy_spec.rb
RSpec.describe "Workspace Tenancy" do
  let(:workspace_a) { create(:workspace) }
  let(:workspace_b) { create(:workspace) }
  let(:user) { create(:user) }
  let(:item_in_a) { create(:item, workspace: workspace_a, schema_slug: "contact") }

  it "cannot access items from another workspace" do
    expect {
      ContactsService::Tools::Show.execute(
        user_id: user.id,
        workspace_id: workspace_b.id,  # Wrong workspace
        id: item_in_a.id
      )
    }.to raise_error(Core::Tools::NotFoundError)
  end

  it "cannot cancel invite from another workspace" do
    invite = create(:invite, workspace: workspace_a)

    expect {
      InvitesService::Tools::Cancel.execute(
        user_id: user.id,
        workspace_id: workspace_b.id,
        invite_id: invite.id
      )
    }.to raise_error(ActiveRecord::RecordNotFound)
  end
end
```

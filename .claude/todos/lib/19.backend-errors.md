# 19. Backend Validation Errors - Rails-style Format

## Goal

Transform validation errors into Rails-style format that Formik can consume directly.
Works for both:
1. **Item model** (JSON Schema validation on `item.data`)
2. **Standard Rails models** (ActiveRecord validations)

---

## Target Error Format

**API Response (422):**
```json
{
  "error": "Validation failed",
  "details": {
    "first_name": ["can't be blank"],
    "last_name": ["can't be blank"],
    "addresses_attributes": [
      { "city": ["can't be blank"] },
      {}
    ],
    "spouse_attributes": {
      "first_name": ["can't be blank"]
    }
  }
}
```

Formik expects errors to **mirror the values structure** ([Formik docs](https://formik.org/docs/guides/arrays)).

---

## Current Problems

### 1. JSON Schema errors are ugly
```
"The property '#/' did not contain a required property of 'first_name' in schema 6b1e3a3d-1d78-5ae2-ae18-3e64ecb9a2c8"
```

### 2. Nested errors not structured for Formik
Currently flat: `{ "data": ["Schema validation failed..."] }`
Need nested: `{ "addresses_attributes": [{ "city": ["can't be blank"] }] }`

### 3. Standard Rails models work differently
ActiveRecord already has nice errors, but nested attributes need proper structure too.

---

## JSON Schema Error Types

| Error Type | Raw Message Pattern | Rails Message |
|------------|---------------------|---------------|
| Missing required | `required property of 'X'` | `can't be blank` |
| Wrong type (string) | `is not of type.*string` | `must be a string` |
| Wrong type (number) | `is not of type.*integer\|number` | `must be a number` |
| Wrong type (boolean) | `is not of type.*boolean` | `must be true or false` |
| Pattern mismatch | `did not match the regex` | `is invalid` |
| Enum invalid | `is not one of` | `is not included in the list` |
| Too short | `has fewer.*than.*allowed` | `is too short` |
| Too long | `has more.*than.*allowed` | `is too long` |
| Below minimum | `is less than.*minimum` | `is too small` |
| Above maximum | `is greater than.*maximum` | `is too large` |
| Extra properties | `additional properties.*not allowed` | `contains unknown fields` |

---

## Implementation

### Phase 1: Create ErrorTransformer

**File:** `packs/core/app/lib/core/validation/error_transformer.rb`

```ruby
# frozen_string_literal: true

module Core
  module Validation
    class ErrorTransformer
      # Transform JSON Schema errors (from errors_as_objects: true) to Rails-style
      #
      # Input:
      #   [{ fragment: "#/", message: "...required property of 'first_name'..." }]
      #
      # Output:
      #   { "first_name" => ["can't be blank"] }
      #
      def self.call(json_schema_errors)
        new(json_schema_errors).transform
      end

      def initialize(errors)
        @errors = errors
        @result = {}
      end

      def transform
        @errors.each do |error|
          process_error(error)
        end
        @result
      end

      private

      def process_error(error)
        fragment = error[:fragment] || ""
        message = error[:message] || ""

        field_path, rails_message = parse_error(fragment, message)
        return unless field_path

        add_error(field_path, rails_message)
      end

      def parse_error(fragment, message)
        # Case 1: Missing required at root - extract field from message
        if (match = message.match(/required property of '([^']+)'/))
          return [match[1], "can't be blank"]
        end

        # Case 2: Field-level error - extract from fragment
        path = fragment.sub(%r{^#/?}, "")
        return nil if path.empty?

        [path, humanize_message(message)]
      end

      def humanize_message(msg)
        case msg
        when /required property of/i then "can't be blank"
        when /is not of type.*string/i then "must be a string"
        when /is not of type.*(integer|number)/i then "must be a number"
        when /is not of type.*boolean/i then "must be true or false"
        when /is not of type.*array/i then "must be an array"
        when /is not of type.*object/i then "must be an object"
        when /did not match the regex/i then "is invalid"
        when /is not one of/i then "is not included in the list"
        when /fewer.*than.*allowed|too short/i then "is too short"
        when /more.*than.*allowed|too long/i then "is too long"
        when /less than.*minimum/i then "is too small"
        when /greater than.*maximum/i then "is too large"
        when /additional properties.*not allowed/i then "contains unknown fields"
        else
          # Clean up: remove schema UUID, fragment references
          msg.gsub(/'#\/[^']*'/, "").gsub(/in schema [a-f0-9-]+/i, "").strip.downcase
        end
      end

      def add_error(field_path, message)
        # Parse path: "addresses_attributes/0/city" => ["addresses_attributes", "0", "city"]
        parts = field_path.split("/")
        set_nested_value(@result, parts, message)
      end

      def set_nested_value(hash, parts, message)
        parts.each_with_index do |part, i|
          is_last = (i == parts.length - 1)
          next_part = parts[i + 1]
          is_next_index = next_part&.match?(/^\d+$/)

          if is_last
            # Leaf - set error array
            hash[part] ||= []
            hash[part] << message unless hash[part].include?(message)
          elsif part.match?(/^\d+$/)
            # Array index
            idx = part.to_i
            hash[idx] ||= {}
            hash = hash[idx]
          else
            # Object key
            if is_next_index
              hash[part] ||= []
            else
              hash[part] ||= {}
            end
            hash = hash[part]
          end
        end
      end
    end
  end
end
```

---

### Phase 2: Update HasSchemaValidation

**File:** `packs/core/app/models/concerns/core/has_schema_validation.rb`

```ruby
# frozen_string_literal: true

require "json-schema"

module Core
  module HasSchemaValidation
    extend ActiveSupport::Concern

    included do
      validate :validate_schema_slug_exists
      validate :validate_data_against_schema, if: -> { data.present? && schema_slug.present? }
    end

    # Public: Get Formik-compatible error structure
    def structured_errors
      return {} unless schema_slug && data

      schema_class = Core::Schema::Registry.find(schema_slug)
      return {} unless schema_class

      json_schema = schema_class.new.to_json_schema[:schema]
      return {} unless json_schema

      clean_data = data.to_h.reject { |k, _| k.to_s.end_with?("_attributes") }

      raw_errors = JSON::Validator.fully_validate(
        json_schema.deep_stringify_keys,
        clean_data.deep_stringify_keys,
        strict: false,
        validate_schema: false,
        errors_as_objects: true
      )

      Core::Validation::ErrorTransformer.call(raw_errors)
    rescue StandardError => e
      Rails.logger.error("Schema validation error: #{e.message}")
      {}
    end

    private

    def validate_schema_slug_exists
      return if schema_slug.blank?
      return if Core::Schema::Registry.find(schema_slug)

      errors.add(:schema_slug, "is not a registered schema")
    end

    def validate_data_against_schema
      structured = structured_errors
      return if structured.empty?

      # Add errors to ActiveRecord for standard Rails flow
      structured.each do |field, messages|
        # Skip nested (arrays/hashes) - only add flat fields to AR errors
        next unless messages.is_a?(Array) && messages.all? { |m| m.is_a?(String) }

        messages.each { |msg| errors.add(field.to_sym, msg) }
      end
    end
  end
end
```

---

### Phase 3: Create ErrorSerializer for Controller

**File:** `packs/core/app/lib/core/validation/error_serializer.rb`

Works for both Item (with structured_errors) and standard Rails models.

```ruby
# frozen_string_literal: true

module Core
  module Validation
    class ErrorSerializer
      # Serialize validation errors for API response
      # Works with:
      #   - Item model (has structured_errors from JSON Schema)
      #   - Standard Rails models (ActiveRecord errors)
      #   - Nested attributes (accepts_nested_attributes_for)
      #
      def self.call(record)
        new(record).serialize
      end

      def initialize(record)
        @record = record
      end

      def serialize
        result = {}

        # 1. Add structured JSON Schema errors (for Item)
        if @record.respond_to?(:structured_errors)
          result.merge!(@record.structured_errors)
        end

        # 2. Add ActiveRecord errors (flat fields)
        @record.errors.each do |error|
          field = error.attribute.to_s
          message = error.message

          # Skip :base errors for now (or add to special key)
          next if field == "base"

          result[field] ||= []
          result[field] << message unless result[field].include?(message)
        end

        # 3. Process nested associations (accepts_nested_attributes_for)
        serialize_nested_errors(result)

        result
      end

      private

      def serialize_nested_errors(result)
        # Find associations with nested errors
        @record.class.reflect_on_all_associations.each do |assoc|
          attr_name = "#{assoc.name}_attributes"
          nested_records = @record.send(assoc.name) rescue nil
          next unless nested_records

          case assoc.macro
          when :has_many
            nested_errors = serialize_has_many(nested_records)
            result[attr_name] = nested_errors if nested_errors.any?
          when :has_one, :belongs_to
            nested = nested_records
            next unless nested&.errors&.any?
            result[attr_name] = ErrorSerializer.call(nested)
          end
        end
      end

      def serialize_has_many(records)
        return [] unless records.respond_to?(:each)

        records.map do |record|
          record.errors.any? ? ErrorSerializer.call(record) : {}
        end
      end
    end
  end
end
```

---

### Phase 4: Update Controller

**File:** `packs/core/app/controllers/core/v1/resources_controller.rb`

```ruby
def validation_errors(record)
  Core::Validation::ErrorSerializer.call(record)
end
```

---

### Phase 5: Frontend - Handle Errors in Form

**File:** `packs/ui/app/frontend/adapters/custom/form/form.tsx`

```typescript
import { useFormikContext } from "formik";

// In form submission:
try {
  await services.fetch(url, { method, data: values });
  // success...
} catch (error) {
  if (error.response?.status === 422) {
    const details = error.response.data?.details;
    if (details) {
      setErrors(details);
    }
  }
}
```

---

## Test Cases

```ruby
RSpec.describe Core::Validation::ErrorTransformer do
  describe ".call" do
    it "transforms missing required field" do
      errors = [{ fragment: "#/", message: "...required property of 'first_name'..." }]
      expect(described_class.call(errors)).to eq({ "first_name" => ["can't be blank"] })
    end

    it "transforms wrong type error" do
      errors = [{ fragment: "#/age", message: "...is not of type integer..." }]
      expect(described_class.call(errors)).to eq({ "age" => ["must be a number"] })
    end

    it "transforms nested array error" do
      errors = [{ fragment: "#/addresses_attributes/0/city", message: "...required..." }]
      expect(described_class.call(errors)).to eq({
        "addresses_attributes" => [{ "city" => ["can't be blank"] }]
      })
    end

    it "transforms nested object error (has_one)" do
      errors = [{ fragment: "#/spouse_attributes/first_name", message: "...required..." }]
      expect(described_class.call(errors)).to eq({
        "spouse_attributes" => { "first_name" => ["can't be blank"] }
      })
    end

    it "deduplicates messages" do
      errors = [
        { fragment: "#/email", message: "...required..." },
        { fragment: "#/email", message: "...required..." }
      ]
      result = described_class.call(errors)
      expect(result["email"].length).to eq(1)
    end
  end
end

RSpec.describe Core::Validation::ErrorSerializer do
  describe ".call" do
    it "serializes Item with JSON Schema errors" do
      item = build(:item, schema_slug: "contact", data: {})
      item.valid?
      
      result = described_class.call(item)
      expect(result).to have_key("first_name")
      expect(result["first_name"]).to include("can't be blank")
    end

    it "serializes standard Rails model" do
      user = User.new
      user.valid?
      
      result = described_class.call(user)
      expect(result).to have_key("email") # assuming email validation
    end
  end
end
```

---

## Files Summary

| File | Action | Purpose |
|------|--------|---------|
| `core/app/lib/core/validation/error_transformer.rb` | CREATE | JSON Schema → Rails messages |
| `core/app/lib/core/validation/error_serializer.rb` | CREATE | Unified error serialization |
| `core/app/models/concerns/core/has_schema_validation.rb` | MODIFY | Add structured_errors method |
| `core/app/controllers/core/v1/resources_controller.rb` | MODIFY | Use ErrorSerializer |
| `core/spec/lib/core/validation/error_transformer_spec.rb` | CREATE | Unit tests |
| `core/spec/lib/core/validation/error_serializer_spec.rb` | CREATE | Unit tests |
| `ui/app/frontend/adapters/custom/form/form.tsx` | MODIFY | setErrors on 422 |

---

## Edge Cases

1. **Sparse arrays**: If error at index 2 but not 0,1 → `[{}, {}, { field: [...] }]`
2. **Deep nesting**: `addresses_attributes/0/phones_attributes/1/number` - recursively nested
3. **Base errors**: Add to `_base` or `base` key
4. **I18n**: Future - use Rails I18n for messages
5. **Multiple validations**: Same field can have multiple error messages

# Rails Parameters: Unified `data:` Convention

## Context

Tools using `params SchemaClass` currently expose flat schema properties (e.g., `first_name`, `last_name`). The API convention uses entity-specific wrappers (`contact: {}`, `rib_request: {}`), but this is inconsistent.

**New convention:** All mutations use `data:` wrapper uniformly.

## RubyLLM DSL Reference

The `params do` block supports nested objects with schema references:

```ruby
params do
  integer :id, required: true
  object :data, of: ContactSchema  # Pulls properties from existing schema
end
```

Produces JSON schema:

```json
{
  "type": "object",
  "properties": {
    "id": { "type": "integer" },
    "data": {
      "type": "object",
      "properties": {
        "first_name": { "type": "string" },
        "last_name": { "type": "string" }
      }
    }
  }
}
```

---

## Execution Steps

### 1. Update RailsParameters to handle nested `data:`

**File:** `packs/core/app/lib/core/tools/rails_parameters.rb`

```ruby
# frozen_string_literal: true

module Core
  module Tools
    module RailsParameters
      # Extracts permitted parameter keys from tool's params_schema
      # Handles both flat params and nested data: {} objects
      def self.permitted_keys(tool_class)
        schema = tool_class.new.params_schema
        return [] unless schema && schema["properties"]

        schema["properties"].keys.map(&:to_sym)
      end

      # Returns the nested structure for strong params permit
      # e.g., [:id, data: [:first_name, :last_name, :email]]
      def self.permit_structure(tool_class)
        schema = tool_class.new.params_schema
        return [] unless schema && schema["properties"]

        build_permit_structure(schema["properties"])
      end

      private_class_method def self.build_permit_structure(properties)
        result = []
        nested = {}

        properties.each do |key, prop|
          key_sym = key.to_sym
          if prop["type"] == "object" && prop["properties"]
            # Nested object - recurse
            nested[key_sym] = build_permit_structure(prop["properties"])
          elsif prop["type"] == "array" && prop.dig("items", "type") == "object"
            # Array of objects
            nested[key_sym] = build_permit_structure(prop.dig("items", "properties") || {})
          else
            # Scalar value
            result << key_sym
          end
        end

        result + (nested.empty? ? [] : [nested])
      end
    end
  end
end
```

### 2. Update ResourcesController to use permit_structure

**File:** `packs/core/app/controllers/core/v1/resources_controller.rb`

Change `tool_params` method:

```ruby
def tool_params
  permitted = Tools::RailsParameters.permit_structure(@tool_class)
  params.permit(*permitted).to_h.deep_symbolize_keys
end
```

---

### 3. Update Tools - Change `params SchemaClass` to `params do` block

#### 3.1 ContactsService::Tools::Create

**File:** `packs/contacts_service/app/lib/contacts_service/tools/create.rb`

**Before:**

```ruby
params ContactSchema

def execute(user_id:, workspace_id:, contact: {}, **_)
  validate!(contact)
  # ...
end
```

**After:**

```ruby
params do
  object :data, of: ContactSchema
end

def execute(user_id:, workspace_id:, data: {}, **_)
  validate!(data)
  # ...
end
```

#### 3.2 ContactsService::Tools::Update

**File:** `packs/contacts_service/app/lib/contacts_service/tools/update.rb`

**Before:**

```ruby
params ContactSchema

def execute(user_id:, workspace_id:, id:, contact: {}, **_)
  item = find_item!(id)
  item.update!(data: item.data.merge(contact.stringify_keys), ...)
end
```

**After:**

```ruby
param :id, type: :integer, desc: "Contact ID", required: true

params do
  object :data, of: ContactSchema
end

def execute(user_id:, workspace_id:, id:, data: {}, **_)
  item = find_item!(id)
  item.update!(data: item.data.merge(data.stringify_keys), ...)
end
```

**Note:** `param :id` and `params do` can coexist - they merge into `params_schema`.

#### 3.3 RibCheckWorkflow::Tools::Create

**File:** `packs/rib_check_workflow/app/lib/rib_check_workflow/tools/create.rb`

**Before:**

```ruby
params RibRequestSchema

def execute(user_id:, workspace_id:, rib_request: {}, **_)
```

**After:**

```ruby
params do
  object :data, of: RibRequestSchema
end

def execute(user_id:, workspace_id:, data: {}, **_)
```

#### 3.4 RibCheckWorkflow::Tools::Update

**File:** `packs/rib_check_workflow/app/lib/rib_check_workflow/tools/update.rb`

**Before:**

```ruby
params RibRequestSchema

def execute(user_id:, workspace_id:, id:, rib_request: {}, **_)
```

**After:**

```ruby
param :id, type: :integer, desc: "RIB request ID", required: true

params do
  object :data, of: RibRequestSchema
end

def execute(user_id:, workspace_id:, id:, data: {}, **_)
```

#### 3.5 ActivitiesService::Tools::Create

**File:** `packs/activities_service/app/lib/activities_service/tools/create.rb`

**Before:**

```ruby
params ActivitySchema
```

**After:**

```ruby
params do
  object :data, of: ActivitySchema
end
```

Update execute signature: `activity: {}` → `data: {}`

#### 3.6 InvitesService::Tools::Create

**File:** `packs/invites_service/app/lib/invites_service/tools/create.rb`

**Before:**

```ruby
params InviteSchema
```

**After:**

```ruby
params do
  object :data, of: InviteSchema
end
```

Update execute signature accordingly.

---

### 4. Update Request Specs (rswag)

#### 4.1 Contacts Spec

**File:** `packs/contacts_service/spec/requests/contacts_spec.rb`

**Lines to change:**

Line 71-84 (POST schema):

```ruby
parameter name: :body, in: :body, schema: {
  type: :object,
  properties: {
    data: {
      type: :object,
      properties: {
        first_name: { type: :string },
        last_name: { type: :string },
        email: { type: :string }
      },
      required: %w[first_name last_name]
    }
  }
}
```

Line 93:

```ruby
let(:body) { { data: { first_name: "John", last_name: "Doe", email: "john@example.com" } } }
```

Line 109:

```ruby
let(:body) { { data: {} } }
```

Line 164-169 (PUT schema):

```ruby
parameter name: :body, in: :body, schema: {
  type: :object,
  properties: {
    data: { type: :object }
  }
}
```

Line 188:

```ruby
let(:body) { { data: { first_name: "Janet" } } }
```

Line 199:

```ruby
let(:body) { { data: { first_name: "Janet" } } }
```

#### 4.2 RIB Requests Spec

**File:** `packs/rib_check_workflow/spec/requests/rib_requests_spec.rb`

Change all occurrences of `rib_request:` to `data:`:

- Line 61: `data: { ... }`
- Line 81: `data: { ... }`
- Line 145: `data: { type: :object }`
- Line 166: `{ data: { status: "pending", message_body: "Updated" } }`
- Line 178: `{ data: { status: "pending" } }`

---

### 5. Update Tool Unit Specs

#### 5.1 RibCheckWorkflow Create Spec

**File:** `packs/rib_check_workflow/spec/lib/rib_check_workflow/tools/create_spec.rb`

Line 32-38:

```ruby
# Before
rib_request: { ... }

# After
data: { ... }
```

Line 68:

```ruby
data: { ... }
```

#### 5.2 RibCheckWorkflow Update Spec

**File:** `packs/rib_check_workflow/spec/lib/rib_check_workflow/tools/update_spec.rb`

Line 41:

```ruby
data: { ... }
```

---

## FRONTEND CHANGES

### 6. Refactor `executeApi` Signature (CRITICAL)

The current signature uses positional arguments which is confusing:

```tsx
// CURRENT (BAD)
executeApi(action, item, options, notification);
// where options.data is the body - confusing!
```

**New signature uses a single object with named keys:**

```tsx
// NEW (CLEAN)
executeApi({
  action: "create",
  url_parameters: { id: 123 }, // for URL interpolation like /contacts/:id
  body: { data: values }, // the HTTP request body
  notification: { success: "...", error: "..." },
});
```

---

### 7. Update View Component Types and Implementation

**File:** `packs/ui/app/frontend/adapters/custom/view/view.tsx`

#### 7.1 Update Types (Lines 23-41)

**Before:**

```tsx
interface ExecuteApiOptions {
  data?: Record<string, unknown>;
}

interface ExecuteApiNotification {
  success?: string;
  error?: string;
}

interface ViewContextValue {
  url: string;
  api: Record<string, { method: string; path: string }>;
  executeApi: (
    action: string,
    item: Record<string, unknown> | null,
    options?: ExecuteApiOptions,
    notification?: ExecuteApiNotification,
  ) => Promise<{ success: boolean; data?: unknown; error?: unknown }>;
}
```

**After:**

```tsx
interface ExecuteApiParams {
  action: string;
  url_parameters?: Record<string, unknown>;
  body?: Record<string, unknown>;
  notification?: {
    success?: string;
    error?: string;
  };
}

interface ViewContextValue {
  url: string;
  api: Record<string, { method: string; path: string }>;
  executeApi: (
    params: ExecuteApiParams,
  ) => Promise<{ success: boolean; data?: unknown; error?: unknown }>;
}
```

#### 7.2 Update executeApi Implementation (Lines 85-135)

**Before:**

```tsx
const executeApi = useCallback(
  async (
    action: string,
    item: Record<string, unknown> | null,
    options?: ExecuteApiOptions,
    notification?: ExecuteApiNotification,
  ): Promise<{ success: boolean; data?: unknown; error?: unknown }> => {
    let resolvedAction = action;
    if (action === "save") {
      resolvedAction = item?.id ? "update" : "create";
    }

    const endpoint = api[resolvedAction];
    if (!endpoint) {
      console.error(`No API endpoint found for action: ${resolvedAction}`);
      return { success: false, error: `No endpoint for ${resolvedAction}` };
    }

    let path = endpoint.path;
    if (item) {
      path = path.replace(/:(\w+)/g, (_, key) => String(item[key] ?? ""));
    }

    const fullUrl = `${url}${path ? `/${path}` : ""}`;

    try {
      const result = await services.fetch(fullUrl, {
        method: endpoint.method,
        body: options?.data,
      });
      // ...
    }
  },
  [api, url, services, queryClient, t],
);
```

**After:**

```tsx
const executeApi = useCallback(
  async ({
    action,
    url_parameters,
    body,
    notification,
  }: ExecuteApiParams): Promise<{
    success: boolean;
    data?: unknown;
    error?: unknown;
  }> => {
    let resolvedAction = action;
    if (action === "save") {
      resolvedAction = url_parameters?.id ? "update" : "create";
    }

    const endpoint = api[resolvedAction];
    if (!endpoint) {
      console.error(`No API endpoint found for action: ${resolvedAction}`);
      return { success: false, error: `No endpoint for ${resolvedAction}` };
    }

    let path = endpoint.path;
    if (url_parameters) {
      path = path.replace(/:(\w+)/g, (_, key) =>
        String(url_parameters[key] ?? ""),
      );
    }

    const fullUrl = `${url}${path ? `/${path}` : ""}`;

    try {
      const result = await services.fetch(fullUrl, {
        method: endpoint.method,
        body,
      });

      if (result?.data) {
        setDrawerData(result.data as Record<string, unknown>);
      }

      await queryClient.invalidateQueries({ queryKey: ["table", url] });

      if (notification?.success) {
        services.toast({ type: "success", message: t(notification.success) });
      }

      return { success: true, data: result };
    } catch (error) {
      if (notification?.error) {
        services.toast({ type: "error", message: t(notification.error) });
      }
      return { success: false, error };
    }
  },
  [api, url, services, queryClient, t],
);
```

---

### 8. Update Form Component

**File:** `packs/ui/app/frontend/adapters/custom/form/form.tsx`

#### Lines 145-168

**Before:**

```tsx
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();

  if (!validateForm()) return;

  setIsSubmitting(true);
  try {
    const formAction = action || "save";
    const item = use_record && drawerData ? drawerData : values;

    await executeApi(
      formAction,
      item as Record<string, unknown>,
      { data: values },
      notification,
    );

    if (onSubmit) await onSubmit(values);
  } catch (error) {
    console.error("Form submission error:", error);
  } finally {
    setIsSubmitting(false);
  }
};
```

**After:**

```tsx
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();

  if (!validateForm()) return;

  setIsSubmitting(true);
  try {
    const formAction = action || "save";
    const record = use_record && drawerData ? drawerData : values;

    await executeApi({
      action: formAction,
      url_parameters: record as Record<string, unknown>,
      body: { data: values },
      notification,
    });

    if (onSubmit) await onSubmit(values);
  } catch (error) {
    console.error("Form submission error:", error);
  } finally {
    setIsSubmitting(false);
  }
};
```

---

### 9. Update Table Stories Mock

**File:** `packs/ui/app/frontend/adapters/custom/table/table.stories.tsx`

#### Lines 5-9

**Before:**

```tsx
const mockViewContext = {
  url: "/api/v1/items",
  api: {},
  executeApi: async () => ({ success: true }),
};
```

**After:**

```tsx
const mockViewContext = {
  url: "/api/v1/items",
  api: {},
  executeApi: async () => ({ success: true }),
};
```

No change needed - the mock just returns `{ success: true }` and doesn't care about arguments.

---

### 10. Update Frontend Tests

#### 10.1 Phase 11 API Test

**File:** `packs/contacts_service/app/frontend/__tests__/integrations/phase-11-api.test.tsx`

##### Line 174 - Test name unchanged, but body assertion changes

**Lines 203-208:**

**Before:**

```tsx
await waitFor(() => {
  expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
    method: "POST",
    body: { name: "Test Contact" },
  });
});
```

**After:**

```tsx
await waitFor(() => {
  expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
    method: "POST",
    body: { data: { name: "Test Contact" } },
  });
});
```

##### Lines 241-246:

**Before:**

```tsx
await waitFor(() => {
  expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
    method: "POST",
    body: { name: "New Contact" },
  });
});
```

**After:**

```tsx
await waitFor(() => {
  expect(mockFetch).toHaveBeenCalledWith("/api/contacts", {
    method: "POST",
    body: { data: { name: "New Contact" } },
  });
});
```

##### Lines 254-261 - Direct executeApi call:

**Before:**

```tsx
function ApiCaller() {
  const { executeApi } = useViewConfig();
  return (
    <button
      onClick={() =>
        executeApi("update", { id: 99 }, { data: { name: "Updated" } })
      }
    >
      Update
    </button>
  );
}
```

**After:**

```tsx
function ApiCaller() {
  const { executeApi } = useViewConfig();
  return (
    <button
      onClick={() =>
        executeApi({
          action: "update",
          url_parameters: { id: 99 },
          body: { data: { name: "Updated" } },
        })
      }
    >
      Update
    </button>
  );
}
```

##### Lines 290-297 - Direct executeApi call:

**Before:**

```tsx
function DeleteButton() {
  const { executeApi } = useViewConfig();
  return (
    <button onClick={() => executeApi("destroy", { id: 5 })}>Delete</button>
  );
}
```

**After:**

```tsx
function DeleteButton() {
  const { executeApi } = useViewConfig();
  return (
    <button
      onClick={() =>
        executeApi({
          action: "destroy",
          url_parameters: { id: 5 },
        })
      }
    >
      Delete
    </button>
  );
}
```

#### 10.2 Phase 10 View Test

**File:** `packs/contacts_service/app/frontend/__tests__/integrations/phase-10-view.test.tsx`

No direct `executeApi` calls with arguments - tests go through form submission. The body expectations may need updating if tests assert on fetch body:

**Check around line 301-303** - if there's a body assertion, update to `{ data: { ... } }`.

#### 10.3 CRUD Page Stories

**File:** `packs/ui/app/frontend/lib/ui-renderer/stories/crud-page.stories.tsx`

**Lines 297-304** - MSW handler for POST:

The MSW handler receives the raw body. If tests expect the handler to work with `body.data`:

**Before:**

```tsx
http.post("/api/v1/contacts", async ({ request }) => {
  const body = await request.json();
  return HttpResponse.json({
    id: 6,
    ...body,
    created_at: new Date().toISOString(),
  });
}),
```

**After:**

```tsx
http.post("/api/v1/contacts", async ({ request }) => {
  const body = await request.json();
  return HttpResponse.json({
    id: 6,
    ...body.data,  // Extract from data wrapper
    created_at: new Date().toISOString(),
  });
}),
```

Same for PUT handler on line 305-308.

---

## Verification

After all changes:

```bash
# Run backend specs
bundle exec rspec packs/contacts_service/spec/requests/contacts_spec.rb
bundle exec rspec packs/rib_check_workflow/spec/requests/rib_requests_spec.rb
bundle exec rspec packs/rib_check_workflow/spec/lib/rib_check_workflow/tools/

# Run frontend tests
npm run test -- --project unit

# Run brakeman
bundle exec brakeman -q
```

All specs should pass. Brakeman should no longer report Mass Assignment warning.

---

## Summary Checklist

### Backend

- [ ] `packs/core/app/lib/core/tools/rails_parameters.rb` - Add `permit_structure` method
- [ ] `packs/core/app/controllers/core/v1/resources_controller.rb` - Use `permit_structure`
- [ ] `packs/contacts_service/app/lib/contacts_service/tools/create.rb` - `params do` + `data:`
- [ ] `packs/contacts_service/app/lib/contacts_service/tools/update.rb` - `params do` + `data:`
- [ ] `packs/rib_check_workflow/app/lib/rib_check_workflow/tools/create.rb` - `params do` + `data:`
- [ ] `packs/rib_check_workflow/app/lib/rib_check_workflow/tools/update.rb` - `params do` + `data:`
- [ ] `packs/activities_service/app/lib/activities_service/tools/create.rb` - `params do` + `data:`
- [ ] `packs/invites_service/app/lib/invites_service/tools/create.rb` - `params do` + `data:`

### Backend Specs

- [ ] `packs/contacts_service/spec/requests/contacts_spec.rb` - `contact:` → `data:`
- [ ] `packs/rib_check_workflow/spec/requests/rib_requests_spec.rb` - `rib_request:` → `data:`
- [ ] `packs/rib_check_workflow/spec/lib/rib_check_workflow/tools/create_spec.rb` - `rib_request:` → `data:`
- [ ] `packs/rib_check_workflow/spec/lib/rib_check_workflow/tools/update_spec.rb` - `rib_request:` → `data:`

### Frontend - executeApi Refactor

- [ ] `packs/ui/app/frontend/adapters/custom/view/view.tsx` - New `ExecuteApiParams` interface + implementation
- [ ] `packs/ui/app/frontend/adapters/custom/form/form.tsx` - Use new executeApi signature with `{ data: values }` body

### Frontend Tests

- [ ] `packs/contacts_service/app/frontend/__tests__/integrations/phase-11-api.test.tsx` - Update executeApi calls and body assertions
- [ ] `packs/contacts_service/app/frontend/__tests__/integrations/phase-10-view.test.tsx` - Update body assertions if any
- [ ] `packs/ui/app/frontend/lib/ui-renderer/stories/crud-page.stories.tsx` - Update MSW handlers to use `body.data`

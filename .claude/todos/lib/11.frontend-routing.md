# 11. Convention-Based Frontend Routing

## Overview

Views with `frontend_route` are automatically exposed as frontend routes. No manual route definitions.

---

## Backend Checklist

- [x] Add `frontend_route` DSL to `Ui::Views::BaseView`
- [x] Add `routable?` class method
- [x] Add `frontend_routes` to `Core::Features::Registry`
- [x] Create `Core::V1::RoutesController#index`
- [x] Add route `resources :routes, only: [:index]` to core routes
- [x] Add `frontend_route "/rib-checks"` to `RibCheckWorkflow::Views::Index`
- [x] Add `frontend_route "/contacts"` to `ContactsService::Views::Index`
- [x] Add `frontend_route "/contacts/:id"` to `ContactsService::Views::Show`
- [x] Write request spec for `/api/v1/routes`

## Frontend Checklist

- [x] Create `@ui/hooks/use-routes.ts`
- [x] Create `@ui/lib/ui-renderer/view-page.tsx`
- [x] Update `main.tsx` with dynamic routing
- [x] Write frontend tests for use-routes and view-page

## Documentation

- [x] Create `.claude/doc/frontend/routing.md`
- [x] Update `.claude/doc/backend/views.md`

---

## Implementation Details

### Backend: View DSL Extension

**File:** `packs/ui/app/lib/ui/views/base_view.rb`

```ruby
class_methods do
  def frontend_route(path = nil)
    if path
      @frontend_route = path
    else
      @frontend_route
    end
  end

  def routable?
    frontend_route.present?
  end
end
```

### Backend: Registry Extension

**File:** `packs/core/app/lib/core/features/registry.rb`

```ruby
def self.frontend_routes
  all.flat_map do |namespace, features|
    features.flat_map do |feature_slug, config|
      (config[:views] || []).filter_map do |view_class|
        next unless view_class.respond_to?(:routable?) && view_class.routable?

        {
          path: view_class.frontend_route,
          namespace: namespace,
          feature: feature_slug,
          view: view_class.name.demodulize.underscore
        }
      end
    end
  end
end
```

### Backend: Routes Controller

**File:** `packs/core/app/controllers/core/v1/routes_controller.rb`

```ruby
module Core
  module V1
    class RoutesController < ResourcesController
      def index
        render json: { routes: Core::Features::Registry.frontend_routes }
      end
    end
  end
end
```

### Frontend: use-routes.ts

**File:** `packs/ui/app/frontend/hooks/use-routes.ts`

```typescript
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

interface RouteEntry {
  path: string;
  namespace: string;
  feature: string;
  view: string;
}

export function useRoutes() {
  return useQuery({
    queryKey: ["routes"],
    queryFn: async () => {
      const { data } = await axios.get<{ routes: RouteEntry[] }>(
        "/api/v1/routes",
      );
      return data.routes;
    },
    staleTime: Infinity,
  });
}
```

### Frontend: view-page.tsx

**File:** `packs/ui/app/frontend/lib/ui-renderer/view-page.tsx`

```typescript
import { useParams } from "react-router";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { DynamicRenderer } from "./renderer";

interface ViewPageProps {
  namespace: string;
  feature: string;
  view: string;
}

export function ViewPage({ namespace, feature, view }: ViewPageProps) {
  const params = useParams();

  const { data: schema, isLoading } = useQuery({
    queryKey: ["view", namespace, feature, view, params],
    queryFn: async () => {
      const { data } = await axios.get(
        `/api/v1/views/${namespace}/${feature}/${view}`,
        { params }
      );
      return data;
    },
  });

  if (isLoading) return <div>Loading...</div>;
  if (!schema) return <div>View not found</div>;

  return <DynamicRenderer schema={schema} />;
}
```

### Frontend: main.tsx (dynamic routes)

**File:** `app/frontend/entrypoints/main.tsx`

```typescript
import { useRoutes } from "@ui/hooks/use-routes";
import { ViewPage } from "@ui/lib/ui-renderer/view-page";

function AppRoutes() {
  const { data: routes, isLoading } = useRoutes();

  if (isLoading) return <LoadingScreen />;

  return (
    <Routes>
      <Route element={<Layout />}>
        <Route index element={<Dashboard />} />
        {routes?.map((route) => (
          <Route
            key={route.path}
            path={route.path}
            element={
              <ViewPage
                namespace={route.namespace}
                feature={route.feature}
                view={route.view}
              />
            }
          />
        ))}
      </Route>
    </Routes>
  );
}
```

---

## API Response Format

**GET /api/v1/routes**

```json
{
  "routes": [
    {
      "path": "/contacts",
      "namespace": "workspaces",
      "feature": "contacts",
      "view": "index"
    },
    {
      "path": "/contacts/:id",
      "namespace": "workspaces",
      "feature": "contacts",
      "view": "show"
    },
    {
      "path": "/rib-checks",
      "namespace": "workspaces",
      "feature": "rib_requests",
      "view": "index"
    }
  ]
}
```

---

## View Examples

**Routable (page):**

```ruby
# rib_check_workflow/views/index.rb
view do
  frontend_route "/rib-checks"  # No /app prefix - basename handles it
  url "/api/v1/workspaces/rib_requests"
  # ...
end
```

**Not routable (drawer content):**

```ruby
# rib_check_workflow/views/form.rb
view do
  # No frontend_route - used in drawers only
  # ...
end
```

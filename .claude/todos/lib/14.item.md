# 14. Item Model - JSON Validation & Nested Attributes

## Summary

Enhance `Item` model with:

1. **JSON Schema validation** against dynamic schemas
2. **Nested attributes processing** (port from 2025-CRM-REGTECH, minimal adaptation)
3. **schema_slug validation** against `Core::Schema::Registry`

---

## Phase 1: Add json-schema gem

```bash
bundle add json-schema
```

---

## Phase 2: Create HasSchemaValidation Concern

**File:** `packs/core/app/models/concerns/core/has_schema_validation.rb`

```ruby
# frozen_string_literal: true

require "json-schema"

module Core
  module HasSchemaValidation
    extend ActiveSupport::Concern

    included do
      validate :validate_schema_slug_exists
      validate :validate_data_against_schema, if: -> { data.present? && schema_slug.present? }
    end

    private

    def validate_schema_slug_exists
      return if schema_slug.blank?
      return if Core::Schema::Registry.find(schema_slug)

      errors.add(:schema_slug, "is not a registered schema")
    end

    def validate_data_against_schema
      schema_class = Core::Schema::Registry.find(schema_slug)
      return unless schema_class

      json_schema = schema_class.new.to_json_schema[:schema]
      return unless json_schema

      # Strip nested attributes before validation
      clean_data = data.to_h.reject { |k, _| k.to_s.end_with?("_attributes") }

      validation_errors = JSON::Validator.fully_validate(
        json_schema.deep_stringify_keys,
        clean_data.deep_stringify_keys,
        strict: false,
        validate_schema: false
      )

      validation_errors.each { |error| errors.add(:data, error) }
    rescue JSON::Schema::ValidationError => e
      errors.add(:data, "Schema validation error: #{e.message}")
    end
  end
end
```

---

## Phase 3: Create NestedAttributesProcessor

Port from 2025-CRM-REGTECH with minimal changes (Sequel → ActiveRecord).

**File:** `packs/core/app/lib/core/processors/nested_attributes_processor.rb`

```ruby
# frozen_string_literal: true

module Core
  module Processors
    class NestedAttributesProcessor
      class << self
        def process_create(source_schema:, source_item_id:, data:, workspace_id:, user_id:)
          normalize_data(data).each do |key, value|
            next unless nested_attributes_key?(key) && value.is_a?(Array)

            assoc_name = key.delete_suffix("_attributes")
            rel_config = find_relationship_config(source_schema, assoc_name)
            next unless rel_config

            value.each do |nested_attrs|
              nested_attrs = normalize_data(nested_attrs)
              process_nested_item_create(nested_attrs, rel_config, source_item_id, workspace_id, user_id)
            end
          end
        end

        def process_update(source_schema:, source_item_id:, data:, workspace_id:, user_id:)
          normalize_data(data).each do |key, value|
            next unless nested_attributes_key?(key) && value.is_a?(Array)

            assoc_name = key.delete_suffix("_attributes")
            rel_config = find_relationship_config(source_schema, assoc_name)
            next unless rel_config

            value.each do |nested_attrs|
              nested_attrs = normalize_data(nested_attrs)
              process_nested_item_update(nested_attrs, rel_config, source_item_id, workspace_id, user_id)
            end
          end
        end

        def strip_nested_attributes(data)
          data.to_h.reject { |k, _| nested_attributes_key?(k) }
        end

        private

        def process_nested_item_create(attrs, rel_config, source_item_id, workspace_id, user_id)
          target_id = attrs["id"]

          if target_id
            return unless Item.exists?(id: target_id)
            ensure_relationship(source_item_id, target_id, rel_config)
            process_create(
              source_schema: rel_config[:target_schema],
              source_item_id: target_id,
              data: attrs,
              workspace_id:, user_id:
            )
          else
            nested_item = create_item(rel_config[:target_schema], attrs, workspace_id, user_id)
            ensure_relationship(source_item_id, nested_item.id, rel_config)
            process_create(
              source_schema: rel_config[:target_schema],
              source_item_id: nested_item.id,
              data: attrs,
              workspace_id:, user_id:
            )
          end
        end

        def process_nested_item_update(attrs, rel_config, source_item_id, workspace_id, user_id)
          target_id = attrs["id"]

          if destroy_flag?(attrs)
            destroy_relationship(source_item_id, target_id, rel_config, user_id) if target_id
            return
          end

          if target_id
            ensure_relationship(source_item_id, target_id, rel_config)
            update_item(target_id, attrs, rel_config[:target_schema], workspace_id, user_id)
          else
            nested_item = create_item(rel_config[:target_schema], attrs, workspace_id, user_id)
            ensure_relationship(source_item_id, nested_item.id, rel_config)
            process_create(
              source_schema: rel_config[:target_schema],
              source_item_id: nested_item.id,
              data: attrs,
              workspace_id:, user_id:
            )
          end
        end

        def nested_attributes_key?(key)
          key.to_s.end_with?("_attributes")
        end

        def normalize_data(data)
          return {} unless data.is_a?(Hash)
          data.transform_keys(&:to_s)
        end

        def destroy_flag?(attrs)
          val = attrs["_destroy"]
          val == true || val == "1" || val == "true" || val == 1
        end

        def create_item(schema_slug, attrs, workspace_id, user_id)
          clean_data = strip_nested_attributes(attrs).except("id", "_destroy")
          Item.create!(
            schema_slug:,
            tool_slug: "nested_create",
            data: clean_data,
            workspace_id:,
            created_by_id: user_id,
            updated_by_id: user_id
          )
        end

        def update_item(item_id, attrs, source_schema, workspace_id, user_id)
          item = Item.find_by(id: item_id)
          return unless item

          clean_data = strip_nested_attributes(attrs).except("id", "_destroy")
          item.update!(data: item.data.merge(clean_data), updated_by_id: user_id) if clean_data.present?

          process_update(
            source_schema:,
            source_item_id: item.id,
            data: attrs,
            workspace_id:, user_id:
          )
        end

        def ensure_relationship(source_item_id, target_item_id, rel_config)
          ItemRelationship.find_or_create_by!(
            source_item_id:,
            target_item_id:,
            relationship_type: rel_config[:type]
          )

          return unless rel_config[:inverse_name]
          ItemRelationship.find_or_create_by!(
            source_item_id: target_item_id,
            target_item_id: source_item_id,
            relationship_type: rel_config[:inverse_name].to_s
          )
        end

        def destroy_relationship(source_item_id, target_item_id, rel_config, user_id)
          ItemRelationship.where(
            source_item_id:,
            target_item_id:,
            relationship_type: rel_config[:type]
          ).destroy_all

          if rel_config[:inverse_name]
            ItemRelationship.where(
              source_item_id: target_item_id,
              target_item_id: source_item_id,
              relationship_type: rel_config[:inverse_name].to_s
            ).destroy_all
          else
            Item.find_by(id: target_item_id)&.update!(deleted_at: Time.current, deleted_by_id: user_id)
          end
        end

        def find_relationship_config(source_schema_slug, assoc_name)
          schema_class = Core::Schema::Registry.find(source_schema_slug)
          return nil unless schema_class&.respond_to?(:find_relationship)

          rel_def = schema_class.find_relationship(assoc_name.to_sym)
          return nil unless rel_def

          {
            type: rel_def[:name].to_s,
            target_schema: rel_def[:target_schema].to_s,
            inverse_name: rel_def[:inverse_name]
          }
        end
      end
    end
  end
end
```

---

## Phase 4: Create HasNestedAttributes Concern

Simple integration - just calls the processor.

**File:** `packs/core/app/models/concerns/core/has_nested_attributes.rb`

```ruby
# frozen_string_literal: true

module Core
  module HasNestedAttributes
    extend ActiveSupport::Concern

    included do
      attr_accessor :_raw_data_with_nested

      after_commit :process_pending_nested_attributes, on: [:create, :update]
    end

    # Override data= to capture nested attributes
    def data=(value)
      return super(value) unless value.is_a?(Hash)

      # Store raw data for after_commit processing
      self._raw_data_with_nested = value.dup

      # Set clean data (without nested attributes)
      super(value.reject { |k, _| k.to_s.end_with?("_attributes") })
    end

    private

    def process_pending_nested_attributes
      return unless _raw_data_with_nested.present?

      method = previously_new_record? ? :process_create : :process_update

      Core::Processors::NestedAttributesProcessor.public_send(
        method,
        source_schema: schema_slug,
        source_item_id: id,
        data: _raw_data_with_nested,
        workspace_id:,
        user_id: created_by_id
      )

      self._raw_data_with_nested = nil
    end
  end
end
```

---

## Phase 5: Update Item Model

**File:** `app/models/item.rb`

```ruby
# frozen_string_literal: true

class Item < ApplicationRecord
  include WorkspaceScoped
  include Core::HasRelationships
  include Core::HasSchemaValidation
  include Core::HasNestedAttributes

  belongs_to :created_by, class_name: "User"
  belongs_to :updated_by, class_name: "User", optional: true
  belongs_to :deleted_by, class_name: "User", optional: true
  has_many :item_recipients, dependent: :destroy
  has_many :documents, dependent: :destroy
  has_many :activities, dependent: :destroy

  validates :schema_slug, presence: true
  validates :tool_slug, presence: true
  validates :data, presence: true
  validates :created_by, presence: true

  scope :active, -> { where(deleted_at: nil) }
  scope :deleted, -> { where.not(deleted_at: nil) }
end
```

---

## Phase 6: Simplify Tools

**File:** `packs/contacts_service/app/lib/contacts_service/tools/create.rb`

```ruby
# frozen_string_literal: true

module ContactsService
  module Tools
    class Create < Core::Tools::Base
      description "Create a new contact"
      route method: :post, scope: :collection
      schema "contact"

      params do
        object :data, of: ContactSchema
      end

      def execute(user_id:, workspace_id:, data: {}, **_)
        item = Item.create!(
          schema_slug: "contact",
          tool_slug: "create",
          data:,
          created_by_id: user_id,
          updated_by_id: user_id,
          workspace_id:
        )

        { data: Core::Serializers::ItemSerializer.new(item).to_h, meta: { created: true } }
      end
    end
  end
end
```

**File:** `packs/contacts_service/app/lib/contacts_service/tools/update.rb`

```ruby
# frozen_string_literal: true

module ContactsService
  module Tools
    class Update < Core::Tools::Base
      description "Update an existing contact"
      route method: :put, scope: :member
      schema "contact"

      params do
        integer :id, required: true
        object :data, of: ContactSchema
      end

      def execute(user_id:, workspace_id:, id:, data: {}, **_)
        item = find_item!(id)
        item.update!(data: item.data.merge(data), updated_by_id: user_id)

        { data: Core::Serializers::ItemSerializer.new(item).to_h, meta: { updated: true } }
      end
    end
  end
end
```

---

## Phase 7: Fix Picker Drawer

**File:** `packs/ui/app/frontend/adapters/custom/relationship-picker/picker-drawer.tsx`

### 7a. Fix pagination (line ~121)

```typescript
pagination: response.meta,  // was response.pagination
```

### 7b. Fix search param (line ~106)

```typescript
params.search = searchQuery; // was params.q
```

---

## Phase 8: Specs

### 8a. HasSchemaValidation Spec

**File:** `packs/core/spec/models/concerns/core/has_schema_validation_spec.rb`

```ruby
# frozen_string_literal: true

require "rails_helper"

RSpec.describe Core::HasSchemaValidation, type: :model do
  let(:workspace) { create(:workspace) }
  let(:user) { create(:user) }

  describe "schema_slug validation" do
    it "fails for unknown schema_slug" do
      item = Item.new(
        schema_slug: "nonexistent",
        tool_slug: "create",
        workspace:,
        created_by: user,
        data: { "foo" => "bar" }
      )

      expect(item).not_to be_valid
      expect(item.errors[:schema_slug]).to include("is not a registered schema")
    end

    it "passes for known schema_slug" do
      item = Item.new(
        schema_slug: "contact",
        tool_slug: "create",
        workspace:,
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe" }
      )

      expect(item).to be_valid
    end
  end

  describe "JSON Schema validation" do
    context "valid data" do
      it "passes with required fields" do
        item = Item.new(
          schema_slug: "contact",
          tool_slug: "create",
          workspace:,
          created_by: user,
          data: { "first_name" => "John", "last_name" => "Doe" }
        )

        expect(item).to be_valid
      end

      it "passes with optional fields" do
        item = Item.new(
          schema_slug: "contact",
          tool_slug: "create",
          workspace:,
          created_by: user,
          data: { "first_name" => "John", "last_name" => "Doe", "email" => "john@example.com" }
        )

        expect(item).to be_valid
      end
    end

    context "invalid data" do
      it "fails for missing required fields" do
        item = Item.new(
          schema_slug: "contact",
          tool_slug: "create",
          workspace:,
          created_by: user,
          data: { "email" => "john@example.com" }
        )

        expect(item).not_to be_valid
        expect(item.errors[:data]).to be_present
      end

      it "fails for wrong type" do
        item = Item.new(
          schema_slug: "contact",
          tool_slug: "create",
          workspace:,
          created_by: user,
          data: { "first_name" => 123, "last_name" => "Doe" }
        )

        expect(item).not_to be_valid
        expect(item.errors[:data]).to be_present
      end
    end

    context "with nested attributes" do
      it "ignores nested attributes during validation" do
        item = Item.new(
          schema_slug: "contact",
          tool_slug: "create",
          workspace:,
          created_by: user,
          data: {
            "first_name" => "John",
            "last_name" => "Doe",
            "children_attributes" => [{ "id" => 999 }]
          }
        )

        expect(item).to be_valid
      end
    end
  end
end
```

### 8b. NestedAttributesProcessor Spec

**File:** `packs/core/spec/lib/core/processors/nested_attributes_processor_spec.rb`

```ruby
# frozen_string_literal: true

require "rails_helper"

RSpec.describe Core::Processors::NestedAttributesProcessor do
  let(:workspace) { create(:workspace) }
  let(:user) { create(:user) }

  describe ".strip_nested_attributes" do
    it "removes keys ending with _attributes" do
      data = {
        "first_name" => "John",
        "children_attributes" => [{ "id" => 1 }],
        "addresses_attributes" => [{ "city" => "NYC" }]
      }

      result = described_class.strip_nested_attributes(data)

      expect(result).to eq({ "first_name" => "John" })
    end
  end

  describe ".process_create" do
    let!(:parent) { create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Parent", "last_name" => "P" }) }
    let!(:child) { create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Child", "last_name" => "C" }) }

    context "linking existing item" do
      it "creates relationship" do
        data = { "children_attributes" => [{ "id" => child.id }] }

        expect {
          described_class.process_create(
            source_schema: "contact",
            source_item_id: parent.id,
            data:,
            workspace_id: workspace.id,
            user_id: user.id
          )
        }.to change(ItemRelationship, :count).by(2)

        expect(ItemRelationship.exists?(source_item_id: parent.id, target_item_id: child.id, relationship_type: "children")).to be true
        expect(ItemRelationship.exists?(source_item_id: child.id, target_item_id: parent.id, relationship_type: "parents")).to be true
      end

      it "ignores non-existent items" do
        data = { "children_attributes" => [{ "id" => 999999 }] }

        expect {
          described_class.process_create(
            source_schema: "contact",
            source_item_id: parent.id,
            data:,
            workspace_id: workspace.id,
            user_id: user.id
          )
        }.not_to change(ItemRelationship, :count)
      end
    end

    context "creating new item" do
      it "creates item and relationship" do
        data = { "children_attributes" => [{ "first_name" => "New", "last_name" => "Child" }] }

        expect {
          described_class.process_create(
            source_schema: "contact",
            source_item_id: parent.id,
            data:,
            workspace_id: workspace.id,
            user_id: user.id
          )
        }.to change(Item, :count).by(1).and change(ItemRelationship, :count).by(2)

        new_child = Item.last
        expect(new_child.data["first_name"]).to eq("New")
        expect(new_child.schema_slug).to eq("contact")
      end
    end
  end

  describe ".process_update" do
    let!(:parent) { create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Parent", "last_name" => "P" }) }
    let!(:child) { create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Child", "last_name" => "C" }) }

    before do
      ItemRelationship.create!(source_item_id: parent.id, target_item_id: child.id, relationship_type: "children")
      ItemRelationship.create!(source_item_id: child.id, target_item_id: parent.id, relationship_type: "parents")
    end

    context "_destroy flag" do
      it "removes relationship with _destroy: true" do
        data = { "children_attributes" => [{ "id" => child.id, "_destroy" => true }] }

        expect {
          described_class.process_update(
            source_schema: "contact",
            source_item_id: parent.id,
            data:,
            workspace_id: workspace.id,
            user_id: user.id
          )
        }.to change(ItemRelationship, :count).by(-2)
      end

      it "removes relationship with _destroy: '1'" do
        data = { "children_attributes" => [{ "id" => child.id, "_destroy" => "1" }] }

        expect {
          described_class.process_update(
            source_schema: "contact",
            source_item_id: parent.id,
            data:,
            workspace_id: workspace.id,
            user_id: user.id
          )
        }.to change(ItemRelationship, :count).by(-2)
      end

      it "keeps item for double-sided relationships" do
        data = { "children_attributes" => [{ "id" => child.id, "_destroy" => true }] }

        described_class.process_update(
          source_schema: "contact",
          source_item_id: parent.id,
          data:,
          workspace_id: workspace.id,
          user_id: user.id
        )

        expect(child.reload.deleted_at).to be_nil
      end
    end
  end
end
```

### 8c. HasNestedAttributes Spec

**File:** `packs/core/spec/models/concerns/core/has_nested_attributes_spec.rb`

```ruby
# frozen_string_literal: true

require "rails_helper"

RSpec.describe Core::HasNestedAttributes, type: :model do
  let(:workspace) { create(:workspace) }
  let(:user) { create(:user) }

  describe "data= setter" do
    it "strips nested attributes from data" do
      item = Item.new(
        schema_slug: "contact",
        tool_slug: "create",
        workspace:,
        created_by: user,
        data: { "first_name" => "John", "last_name" => "Doe", "children_attributes" => [{ "id" => 1 }] }
      )

      expect(item.data).to eq({ "first_name" => "John", "last_name" => "Doe" })
    end

    it "stores raw data for processing" do
      item = Item.new(
        schema_slug: "contact",
        tool_slug: "create",
        workspace:,
        created_by: user,
        data: { "first_name" => "John", "children_attributes" => [{ "id" => 1 }] }
      )

      expect(item._raw_data_with_nested).to include("children_attributes")
    end
  end

  describe "after_commit processing" do
    let!(:child) { create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Child", "last_name" => "C" }) }

    it "creates relationships on create" do
      item = Item.create!(
        schema_slug: "contact",
        tool_slug: "create",
        workspace:,
        created_by: user,
        data: { "first_name" => "Parent", "last_name" => "P", "children_attributes" => [{ "id" => child.id }] }
      )

      expect(ItemRelationship.exists?(source_item_id: item.id, target_item_id: child.id, relationship_type: "children")).to be true
    end

    it "creates relationships on update" do
      item = create(:item, schema_slug: "contact", workspace:, created_by: user, data: { "first_name" => "Parent", "last_name" => "P" })

      item.update!(data: { "first_name" => "Parent", "last_name" => "P", "children_attributes" => [{ "id" => child.id }] })

      expect(ItemRelationship.exists?(source_item_id: item.id, target_item_id: child.id, relationship_type: "children")).to be true
    end
  end
end
```

---

## Files Summary

| File                                                                      | Action            |
| ------------------------------------------------------------------------- | ----------------- |
| `Gemfile`                                                                 | Add `json-schema` |
| `packs/core/app/models/concerns/core/has_schema_validation.rb`            | CREATE            |
| `packs/core/app/models/concerns/core/has_nested_attributes.rb`            | CREATE            |
| `packs/core/app/lib/core/processors/nested_attributes_processor.rb`       | CREATE            |
| `app/models/item.rb`                                                      | UPDATE            |
| `packs/contacts_service/.../tools/create.rb`                              | SIMPLIFY          |
| `packs/contacts_service/.../tools/update.rb`                              | SIMPLIFY          |
| `packs/ui/.../picker-drawer.tsx`                                          | FIX               |
| `packs/core/spec/models/concerns/core/has_schema_validation_spec.rb`      | CREATE            |
| `packs/core/spec/models/concerns/core/has_nested_attributes_spec.rb`      | CREATE            |
| `packs/core/spec/lib/core/processors/nested_attributes_processor_spec.rb` | CREATE            |

---

## Key Differences from Original

| Aspect              | 2025-CRM-REGTECH                         | This Implementation      |
| ------------------- | ---------------------------------------- | ------------------------ | --- |
| ORM                 | Sequel                                   | ActiveRecord             |
| `Item[id]`          | `Item.find_by(id:)`                      | ✓                        |
| `.create`           | `.create!`                               | ✓                        |
| `.where(...).first` | `.find_by(...)` or `.find_or_create_by!` | ✓                        |
| `.delete`           | `.destroy_all`                           | ✓                        |
| Repository pattern  | Concern + after_commit                   | ✓                        |
| Schema lookup       | `Inventory::Registry`                    | `Core::Schema::Registry` | ✓   |

---

## Execution Order

1. `bundle add json-schema`
2. Create `NestedAttributesProcessor`
3. Create `HasSchemaValidation` concern
4. Create `HasNestedAttributes` concern
5. Update `Item` model
6. Run specs
7. Simplify tools
8. Fix picker-drawer

# 09. Global Translations for Layout

## Goal

Hydrate frontend with global translations from `config/locales/*.yml` without introducing a second i18n system.

## Current System

- **Ruby views**: Define translations inline via `translations(en: {...}, fr: {...})`
- **Frontend**: `UIProvider` receives `translations` prop, exposes `t(key, namespace?)` via `useTranslate()` hook
- **Lookup order**: `views[key]` → `common[key]` → `schemas[namespace][key]` → fallback to key

## Tasks

### 1. Backend: Add globals to `config/locales/en.yml`

```yaml
en:
  globals:
    menu:
      applications: "Applications"
      rib_checks: "RIB Checks"
    cta:
      invite_title: "Invite Members"
      invite_description: "Invite your team to collaborate on this workspace."
      invite_button: "Invite"
    user:
      edit_profile: "Edit Profile"
      logout: "Log out"
    workspace:
      add: "Add workspace"
```

### 2. Backend: Expose globals via API endpoint

Returns all locales (matches Ruby inline translations pattern):

```ruby
# GET /api/v1/translations?scope=globals
def index
  render json: {
    translations: {
      en: I18n.t('globals', locale: :en),
      fr: I18n.t('globals', locale: :fr)
    }
  }
end
```

Response:

```json
{
  "translations": {
    "en": { "menu": { "applications": "Applications" }, ... },
    "fr": { "menu": { "applications": "Applications" }, ... }
  }
}
```

### 3. Frontend: Extend TranslationsMap type

**File**: `packs/ui/app/frontend/lib/ui-renderer/types.ts`

Add `globals` to interface:

```typescript
export interface TranslationsMap {
  schemas: Record<string, Record<string, string>>;
  views: Record<string, Record<string, string>>;
  common: Record<string, string>;
  globals: Record<string, string>; // ADD
}
```

### 4. Frontend: Update UIProvider lookup

**File**: `packs/ui/app/frontend/lib/ui-renderer/provider.tsx`

Add `globals` to `t()` lookup order.

### 5. Frontend: Fetch/merge globals in AppUIProvider

**File**: `app/frontend/providers/ui-provider.tsx`

Fetch globals and merge into translations prop.

### 6. Frontend: Use `t()` in layout.tsx

**File**: `app/frontend/views/layout.tsx`

```typescript
const { t } = useUI();

const menuOptions = [
  {
    title: t("globals.menu.applications"),
    items: [{ title: t("globals.menu.rib_checks"), url: "/app/rib-checks" }],
  },
];
```

## Key Principle

- `app-components/layout/*` components are **dumb** - no hooks
- They receive **pre-translated strings** as props
- Translation happens in `layout.tsx` via `useUI().t()`
- Single system: Rails I18n → UIProvider → `t()` hook

## Testing: Translation Key Snapshots

Snapshot test to catch unacknowledged translation key changes. Test fails when keys are added/removed/renamed - forces explicit update.

**File**: `spec/lib/translations_spec.rb`

```ruby
RSpec.describe "Global translations" do
  let(:translations) { YAML.load_file(Rails.root.join("config/locales/en.yml")) }
  let(:globals) { translations.dig("en", "globals") }

  it "matches expected keys snapshot" do
    expected_keys = %w[
      menu.applications
      menu.rib_checks
      cta.invite_title
      cta.invite_description
      cta.invite_button
      user.edit_profile
      user.logout
      workspace.add
    ]

    actual_keys = flatten_keys(globals)

    expect(actual_keys.sort).to eq(expected_keys.sort)
  end

  private

  def flatten_keys(hash, prefix = nil)
    hash.flat_map do |key, value|
      full_key = [prefix, key].compact.join(".")
      value.is_a?(Hash) ? flatten_keys(value, full_key) : full_key
    end
  end
end
```

**Purpose**: Forces developer to explicitly acknowledge translation key changes by updating the snapshot array.

## Testing: Frontend AppUIProvider

**File**: `app/frontend/providers/__tests__/ui-provider.test.tsx`

```typescript
import axios from "axios";
import MockAdapter from "axios-mock-adapter";

const mockAxios = new MockAdapter(axios);

describe("AppUIProvider with globals", () => {
  beforeEach(() => {
    mockAxios.reset();
  });

  it("fetches and merges global translations", async () => {
    mockAxios.onGet("/api/v1/translations").reply(200, {
      translations: {
        en: { menu: { applications: "Applications" } },
        fr: { menu: { applications: "Applications" } },
      },
    });

    render(
      <AppUIProvider>
        <TestComponent />
      </AppUIProvider>
    );

    await waitFor(() => {
      expect(screen.getByText("Applications")).toBeInTheDocument();
    });
  });

  it("uses correct locale for translations", async () => {
    mockAxios.onGet("/api/v1/translations").reply(200, {
      translations: {
        en: { menu: { applications: "Applications" } },
        fr: { menu: { applications: "Applications" } },
      },
    });

    render(
      <AppUIProvider locale="fr">
        <TestComponent />
      </AppUIProvider>
    );

    await waitFor(() => {
      expect(screen.getByText("Applications")).toBeInTheDocument();
    });
  });
});
```

## Testing: Layout Component

**File**: `app/frontend/views/__tests__/layout.test.tsx`

```typescript
import { render, screen, within, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { MemoryRouter } from "react-router";
import Layout from "../layout";

// Test wrapper with providers
const TestWrapper = ({ children, translations, user, isLoading = false }) => (
  <MemoryRouter>
    <MockAuthProvider user={user} isLoading={isLoading}>
      <MockUIProvider translations={translations}>
        {children}
      </MockUIProvider>
    </MockAuthProvider>
  </MemoryRouter>
);

const mockTranslations = {
  globals: {
    menu: { applications: "Applications", rib_checks: "RIB Checks" },
    cta: {
      invite_title: "Invite Members",
      invite_description: "Invite your team to collaborate.",
      invite_button: "Invite",
    },
    user: { edit_profile: "Edit Profile", logout: "Log out" },
    workspace: { add: "Add workspace" },
  },
};

const mockUser = {
  name: "John Doe",
  email: "john@example.com",
  avatar: "/avatars/john.jpg",
  login: "johndoe",
};

describe("Layout", () => {
  describe("loading state", () => {
    it("shows loading indicator when auth is loading", () => {
      render(
        <TestWrapper translations={mockTranslations} isLoading={true}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("Loading...")).toBeInTheDocument();
      expect(screen.queryByRole("navigation")).not.toBeInTheDocument();
    });
  });

  describe("sidebar structure", () => {
    it("renders sidebar with header, content, and footer", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByRole("navigation")).toBeInTheDocument();
      expect(screen.getByRole("main")).toBeInTheDocument();
    });
  });

  describe("workspace switcher", () => {
    it("renders current workspace name and plan", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("Acme Inc")).toBeInTheDocument();
      expect(screen.getByText("Enterprise")).toBeInTheDocument();
    });

    it("opens dropdown and shows workspaces list", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("Acme Inc"));

      expect(screen.getByText("Workspaces")).toBeInTheDocument();
    });

    it("shows add workspace option in dropdown", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("Acme Inc"));

      expect(screen.getByText("Add workspace")).toBeInTheDocument();
    });

    it("calls onAddWorkspace when add option clicked", async () => {
      const onAddWorkspace = vi.fn();
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("Acme Inc"));
      await userEvent.click(screen.getByText("Add workspace"));

      // TODO: verify callback when wired up
    });
  });

  describe("navigation menu", () => {
    it("renders menu group label", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      const sidebar = screen.getByRole("navigation");
      expect(within(sidebar).getByText("Applications")).toBeInTheDocument();
    });

    it("renders menu items with correct labels", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      const sidebar = screen.getByRole("navigation");
      expect(within(sidebar).getByText("RIB Checks")).toBeInTheDocument();
    });

    it("renders menu item links with correct URLs", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      const link = screen.getByRole("link", { name: /RIB Checks/i });
      expect(link).toHaveAttribute("href", "/app/rib-checks");
    });

    it("expands collapsible menu by default when isActive", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      // RIB Checks should be visible (parent is isActive: true)
      expect(screen.getByText("RIB Checks")).toBeVisible();
    });
  });

  describe("CTA card", () => {
    it("renders CTA title and description", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("Invite Members")).toBeInTheDocument();
      expect(screen.getByText("Invite your team to collaborate.")).toBeInTheDocument();
    });

    it("renders CTA button with correct label", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByRole("button", { name: "Invite" })).toBeInTheDocument();
    });

    it("calls onAction when CTA button clicked", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByRole("button", { name: "Invite" }));

      // TODO: verify callback when wired up
    });
  });

  describe("user footer", () => {
    it("renders user name and email", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("john@example.com")).toBeInTheDocument();
    });

    it("renders user avatar", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      const avatar = screen.getByRole("img", { name: "John Doe" });
      expect(avatar).toHaveAttribute("src", "/avatars/john.jpg");
    });

    it("renders initials when no avatar", () => {
      const userWithoutAvatar = { ...mockUser, avatar: undefined };
      render(
        <TestWrapper translations={mockTranslations} user={userWithoutAvatar}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("JD")).toBeInTheDocument();
    });

    it("falls back to login when no name", () => {
      const userWithoutName = { ...mockUser, name: undefined };
      render(
        <TestWrapper translations={mockTranslations} user={userWithoutName}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByText("johndoe")).toBeInTheDocument();
    });

    it("opens user dropdown on click", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("John Doe"));

      expect(screen.getByText("Edit Profile")).toBeInTheDocument();
      expect(screen.getByText("Log out")).toBeInTheDocument();
    });

    it("shows user actions in dropdown", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("John Doe"));

      expect(screen.getByText("Edit Profile")).toBeInTheDocument();
    });

    it("calls action onClick when action clicked", async () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("John Doe"));
      await userEvent.click(screen.getByText("Edit Profile"));

      // TODO: verify callback when wired up
    });

    it("redirects to /logout when logout clicked", async () => {
      const originalLocation = window.location;
      delete (window as any).location;
      window.location = { href: "" } as Location;

      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      await userEvent.click(screen.getByText("John Doe"));
      await userEvent.click(screen.getByText("Log out"));

      expect(window.location.href).toBe("/logout");

      window.location = originalLocation;
    });
  });

  describe("main content", () => {
    it("renders Outlet for child routes", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      expect(screen.getByRole("main")).toBeInTheDocument();
    });
  });

  describe("sidebar collapse", () => {
    it("renders with collapsible icon mode", () => {
      render(
        <TestWrapper translations={mockTranslations} user={mockUser}>
          <Layout />
        </TestWrapper>
      );

      // SidebarRail should be present for collapse functionality
      expect(screen.getByRole("navigation")).toBeInTheDocument();
    });
  });
});
```
